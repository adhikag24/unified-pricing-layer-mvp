<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Unified Order Pricing Read Layer Assessment - Acceptance Criteria</title>
    <style>
        :root {
            --bg-dark: #0d1117;
            --bg-card: #161b22;
            --border-color: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-yellow: #d29922;
            --accent-red: #f85149;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 2px solid var(--border-color);
        }

        .header h1 {
            font-size: 2.5rem;
            color: var(--accent-blue);
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 1.1rem;
            color: var(--text-secondary);
        }

        .table-wrapper {
            overflow-x: auto;
            margin-bottom: 3rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background-color: var(--bg-card);
        }

        thead {
            background-color: #1c2128;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            color: var(--accent-blue);
            border-bottom: 2px solid var(--border-color);
            white-space: nowrap;
        }

        td {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            vertical-align: top;
        }

        tr:hover {
            background-color: rgba(88, 166, 255, 0.05);
        }

        .requirement {
            font-weight: 600;
            color: var(--accent-green);
            min-width: 200px;
        }

        .user-story {
            min-width: 300px;
            color: var(--text-primary);
        }

        .acceptance-criteria {
            min-width: 400px;
        }

        .implementation-notes {
            min-width: 300px;
            color: var(--text-secondary);
        }

        .test-scenarios {
            min-width: 400px;
        }

        .criteria-section {
            margin-bottom: 1.5rem;
        }

        .criteria-section strong {
            display: block;
            color: var(--accent-yellow);
            margin-bottom: 0.5rem;
        }

        .criteria-section ul {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
        }

        .criteria-section li {
            margin-bottom: 0.3rem;
        }

        code {
            background-color: rgba(110, 118, 129, 0.2);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
            color: var(--accent-blue);
        }

        .test-case {
            background-color: rgba(88, 166, 255, 0.1);
            padding: 0.8rem;
            border-left: 3px solid var(--accent-blue);
            margin-bottom: 1rem;
            border-radius: 4px;
        }

        .test-case-title {
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 0.5rem;
        }

        .impl-note {
            background-color: rgba(139, 148, 158, 0.1);
            padding: 0.8rem;
            border-left: 3px solid var(--text-secondary);
            margin-bottom: 0.8rem;
            border-radius: 4px;
        }

        .note-label {
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.3rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Enhanced Unified Order Pricing Read Layer</h1>
        <p>Comprehensive Acceptance Criteria & Implementation Guide</p>
        <p style="margin-top: 0.5rem; color: var(--accent-green); font-weight: 600;">✅ Updated for v1.1.0 Implementation (2025-11-10)</p>
    </div>

    <div class="table-wrapper">
        <table>
            <thead>
                <tr>
                    <th>Requirement</th>
                    <th>User Story</th>
                    <th>Acceptance Criteria</th>
                    <th>Implementation Notes</th>
                    <th>Test Scenarios</th>
                </tr>
            </thead>
            <tbody>
                <!-- Row 1: Standardized Pricing Event Schema -->
                <tr>
                    <td class="requirement">Standardized Pricing Event Schema – [Component Data - Vertical Initiated]</td>
                    <td class="user-story">
                        As a Vertical PM/Component Owner, I want to share detailed pricing breakdown for a specialized pricing store in a standardized manner, so that everyone can understand what constitutes an Order across multiple repricing or operational events
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Event Contract Structure:</strong>
                            <ul>
                                <li>Define single event contract: <code>PricingUpdated</code> with schema version <code>pricing.commerce.v1</code></li>
                                <li>Event must include:
                                    <ul>
                                        <li><code>event_id</code> (optional - Order Core generates if missing)</li>
                                        <li><code>event_type</code>: "PricingUpdated"</li>
                                        <li><code>order_id</code>: Order identifier</li>
                                        <li><code>vertical</code>: (optional) e.g., "accommodation", "flight"</li>
                                        <li><code>emitted_at</code>: ISO8601 timestamp</li>
                                        <li><code>emitter_service</code>: (optional) producing service name</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Customer Context (B2B/B2C scenarios):</strong>
                            <ul>
                                <li><code>customer_context</code> object with:
                                    <ul>
                                        <li><code>reseller_type_name</code>: "B2C", "B2B_AFFILIATE", "B2B_CORPORATE"</li>
                                        <li><code>reseller_id</code>: (optional) Partner identifier</li>
                                        <li><code>reseller_name</code>: (optional) Partner display name</li>
                                        <li><code>account_id</code>: (optional) Customer/account identifier</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Detail Context (Multi-Order-Detail Support - Option A):</strong>
                            <ul>
                                <li>Support BOTH:
                                    <ul>
                                        <li><code>detail_context</code> (legacy): Single context for backward compatibility</li>
                                        <li><code>detail_contexts</code> (new): Array of contexts for multiple order_details</li>
                                    </ul>
                                </li>
                                <li>Each context contains:
                                    <ul>
                                        <li><code>order_detail_id</code>: Unique detail identifier</li>
                                        <li><code>entity_context</code>: "GTN", "TNPL", merchant_of_record, supplier_entity, customer_entity</li>
                                        <li><code>fx_context</code> (if multi-currency): timestamp_fx_rate/as_of, currencies, rates, source</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Component Breakdown:</strong>
                            <ul>
                                <li><code>components</code>: Array of pricing components with:
                                    <ul>
                                        <li><code>component_type</code>: Union[ComponentType enum, string]</li>
                                        <li><code>amount</code>: Union[int, float] - smallest currency unit or decimal</li>
                                        <li><code>currency</code>: Currency code</li>
                                        <li><code>dimensions</code>: Dict[str, str] - Granularity indicators</li>
                                        <li><code>description</code>: (optional) Human-readable description</li>
                                        <li><code>is_refund</code>: (optional) Boolean flag</li>
                                        <li><code>refund_of_component_semantic_id</code>: (optional) Lineage pointer</li>
                                        <li><code>meta</code> or <code>metadata</code>: (optional) Vertical-specific extensions</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Totals Validation:</strong>
                            <ul>
                                <li><code>totals</code> (optional but recommended): customer_total, currency</li>
                                <li>Order Core validates sum matches within epsilon</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Pydantic Models (v1.0.5+):</div>
                            <ul>
                                <li><code>PricingUpdatedEvent</code> in <code>events.py</code></li>
                                <li><code>PricingComponent</code> with Union types (ComponentType enum + string)</li>
                                <li><code>DetailContext</code> with entity_context and fx_context</li>
                                <li><code>CustomerContext</code> for B2B/B2C (all fields optional)</li>
                                <li><code>EntityContext</code> - Legal entity tracking (TNPL, GTN)</li>
                                <li><code>FXContext</code> - Multi-currency with FX rates</li>
                                <li>Support for both <code>meta</code> and <code>metadata</code> fields</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Normalization Logic:</div>
                            <ul>
                                <li><code>pipeline.py::_ingest_pricing_updated()</code></li>
                                <li>Context map building from detail_contexts array (Option A)</li>
                                <li>Dual ID generation per component</li>
                                <li>Metadata enrichment with matched context (entity + FX)</li>
                                <li>Backward compatible with detail_context (singular)</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Storage:</div>
                            <ul>
                                <li><code>pricing_components_fact</code> table</li>
                                <li>All component fields + enrichment</li>
                                <li>JSON columns: dimensions, metadata (entity + FX context)</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Real Schema Support (v1.0.5):</div>
                            <ul>
                                <li>Validated with real B2B affiliate production data</li>
                                <li>New component types: RoomRate, AffiliateShareback, VAT</li>
                                <li>Supports components-helper/b2b_affiliate_case JSON files</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Single Order Detail</div>
                            <ul>
                                <li>Vertical emits event with <code>detail_context</code> (singular)</li>
                                <li>All components have same order_detail_id in dimensions</li>
                                <li>Verify context applied to all components</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Multi Order Detail (Option A)</div>
                            <ul>
                                <li>Vertical emits event with <code>detail_contexts</code> (array)</li>
                                <li>Components have different order_detail_id values</li>
                                <li>Verify each component matched to correct context</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: B2B Affiliate Context</div>
                            <ul>
                                <li>Event includes <code>customer_context</code> with reseller_id and account_id</li>
                                <li>Verify stored in component metadata</li>
                                <li>Query by reseller_id succeeds</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: B2C Context (Optional Fields)</div>
                            <ul>
                                <li>Event includes <code>customer_context</code> with only reseller_type_name = "B2C" and account_id</li>
                                <li>reseller_id and reseller_name are omitted (optional)</li>
                                <li>Verify ingestion succeeds without validation error</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Component Type Extensibility</div>
                            <ul>
                                <li>Send custom component_type string (e.g., "LoyaltyPoints")</li>
                                <li>Verify ingestion succeeds (Union[ComponentType, str])</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Totals Validation</div>
                            <ul>
                                <li>Send event with totals.customer_total = 100000</li>
                                <li>Components sum to 100000 → Success</li>
                                <li>Components sum to 99999 → Warning logged, ingestion succeeds</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 2: Payment Lifecycle Information -->
                <tr>
                    <td class="requirement">Payment Lifecycle Information - [Non-Component Data - Payment initiated]</td>
                    <td class="user-story">
                        As an Order PM, I want a single versioned payment timeline, so that the system always knows the latest payment state across multiple partial captures or refunds, enabling clarity between "issued but not paid", "paid and issued", etc.
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Event Contract: PaymentLifecycleEvent</strong>
                            <ul>
                                <li><code>event_type</code>: "PaymentLifecycle"</li>
                                <li><code>schema_version</code>: "payment.timeline.v1"</li>
                                <li><code>order_id</code>: Order identifier</li>
                                <li><code>emitted_at</code>: ISO8601 timestamp</li>
                                <li><code>payment</code> (required nested object) with:
                                    <ul>
                                        <li><code>status</code>: "Authorized", "Captured", "Refunded", "Settled"</li>
                                        <li><code>payment_id</code>: Payment intent ID</li>
                                        <li><code>pg_reference_id</code>: Payment gateway reference</li>
                                        <li><code>payment_method</code>: channel, provider, brand</li>
                                        <li><code>currency</code>, <code>authorized_amount</code>, <code>captured_amount</code>, <code>captured_amount_total</code></li>
                                        <li><code>instrument</code>: Masked payment instrument (VA, CARD, EWALLET, BNPL, QR)</li>
                                        <li><code>bnpl_plan</code>: BNPL-specific data with schedules</li>
                                    </ul>
                                </li>
                                <li><code>idempotency_key</code>: (optional) For exactly-once processing</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Backward Compatibility:</strong>
                            <ul>
                                <li>Support legacy flat structure (deprecated): payment_method (string), amount, currency at root level</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Normalization (Order Core):</strong>
                            <ul>
                                <li>Assigns <code>timeline_version</code> (monotonic per order_id)</li>
                                <li>Does NOT contain timeline_version in producer event (enrichment only)</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Pydantic Models:</div>
                            <ul>
                                <li><code>PaymentLifecycleEvent</code> in <code>events.py</code></li>
                                <li><code>Payment</code> nested object</li>
                                <li><code>PaymentMethod</code>, <code>PaymentInstrument</code> classes</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Normalization:</div>
                            <ul>
                                <li><code>pipeline.py::_ingest_payment_lifecycle()</code></li>
                                <li>Extracts nested payment object OR legacy flat</li>
                                <li>Assigns timeline_version</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Storage:</div>
                            <ul>
                                <li><code>payment_timeline</code> table</li>
                                <li>JSON columns: instrument, bnpl_plan, metadata</li>
                                <li>Timeline version indexed</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Authorized Event</div>
                            <ul>
                                <li>Payment emits event with status = "Authorized"</li>
                                <li>authorized_amount = 500000, captured_amount = 0</li>
                                <li>Verify timeline_version = 1</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Captured Event (Full)</div>
                            <ul>
                                <li>Payment emits event with status = "Captured"</li>
                                <li>captured_amount = 500000, captured_amount_total = 500000</li>
                                <li>Instrument masked correctly</li>
                                <li>Verify timeline_version = 2</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Partial Capture</div>
                            <ul>
                                <li>First capture: captured_amount = 200000, total = 200000 → v3</li>
                                <li>Second capture: captured_amount = 300000, total = 500000 → v4</li>
                                <li>Query latest: verify captured_amount_total = 500000</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: BNPL with Schedules</div>
                            <ul>
                                <li>bnpl_plan.schedules has 3 installments</li>
                                <li>Schedule[0]: captured_amount = 100000 (downpay)</li>
                                <li>Schedule[1], [2]: captured_amount = null (pending)</li>
                                <li>Verify JSON storage and retrieval</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Instrument Masking</div>
                            <ul>
                                <li>VA: account_number_masked contains "•••"</li>
                                <li>Card: last4 only, no full PAN</li>
                                <li>EWallet: phone_masked with "•••"</li>
                                <li>Verify no sensitive data stored</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Idempotency</div>
                            <ul>
                                <li>Emit same event twice with same idempotency_key</li>
                                <li>Verify only one row inserted</li>
                                <li>Verify no duplicate timeline_version</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 3: Supplier Lifecycle Handling -->
                <tr>
                    <td class="requirement">Issuance/Supplier Lifecycle Handling [Non-Component Data - Supplier Initiated]</td>
                    <td class="user-story">
                        As an Order PM, I want to retrieve detailed supplier/issuance data with its lineage if there are changes, so that we have complete supplier booking history
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Event Contract: SupplierLifecycleEvent</strong>
                            <ul>
                                <li><code>event_type</code>: "IssuanceSupplierLifecycle"</li>
                                <li><code>schema_version</code>: "supplier.timeline.v1"</li>
                                <li><code>order_id</code>, <code>order_detail_id</code>, <code>emitted_at</code></li>
                                <li><code>supplier</code> (required nested object) with:
                                    <ul>
                                        <li><code>status</code>: "ISSUED", "Confirmed", "CancelledNoFee", "CancelledWithFee", etc.</li>
                                        <li><code>supplier_id</code>, <code>booking_code</code>, <code>supplier_ref</code></li>
                                        <li><code>amount_due</code>, <code>currency</code></li>
                                        <li><code>fx_context</code>, <code>entity_context</code> (optional)</li>
                                        <li><code>affiliate</code> (optional) for B2B: reseller_id, reseller_name, partnerShareback, taxes</li>
                                        <li><code>supplier_commission</code> (optional): commission paid TO supplier</li>
                                        <li><code>cancellation</code> (optional): fee_amount, fee_currency</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Normalization (Order Core):</strong>
                            <ul>
                                <li>Assigns <code>supplier_timeline_version</code> (monotonic per order_detail_id)</li>
                                <li>Creates payable lines: SUPPLIER, AFFILIATE_COMMISSION, TAX_WITHHOLDING, SUPPLIER_COMMISSION</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Status-Driven Obligation Model:</strong>
                            <ul>
                                <li>ISSUED/Confirmed: amount_due is baseline, include commission/tax</li>
                                <li>CancelledWithFee: cancellation_fee is baseline, EXCLUDE commission/tax</li>
                                <li>CancelledNoFee: 0 baseline, EXCLUDE commission/tax</li>
                                <li>Adjustments (version = -1) ALWAYS included regardless of status</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Pydantic Models (v1.0.5-1.0.8):</div>
                            <ul>
                                <li><code>SupplierLifecycleEvent</code> in <code>events.py</code></li>
                                <li><code>Supplier</code> - Nested object with status, amounts, affiliate data</li>
                                <li><code>Affiliate</code> - With reseller_id, reseller_name, partnerShareback, taxes</li>
                                <li><code>SupplierCommission</code> - Commission paid TO supplier</li>
                                <li><code>Cancellation</code> - With fee_amount and fee_currency (v1.0.8)</li>
                                <li>Supports both nested supplier object and legacy flat fields</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Normalization (v1.0.6):</div>
                            <ul>
                                <li><code>pipeline.py::_ingest_supplier_lifecycle()</code></li>
                                <li>Creates multiple payable lines per event (SUPPLIER, AFFILIATE_COMMISSION, TAX_WITHHOLDING)</li>
                                <li>Extracts reseller info from supplier.affiliate object</li>
                                <li>Handles decimal amounts correctly for IDR (zero-decimal currency)</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Storage (v1.0.6-1.0.8):</div>
                            <ul>
                                <li><code>supplier_timeline</code> table - Status progression with cancellation fee columns</li>
                                <li><code>supplier_payable_lines</code> table - Multi-party breakdown with amount_effect</li>
                                <li>Query methods: get_supplier_effective_payables() (ROW_NUMBER window), get_payables_by_party(), get_payables_timeline()</li>
                                <li>Supports rebooking: tracks multiple supplier instances per order_detail</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Initial Issuance</div>
                            <ul>
                                <li>Vertical emits ISSUED status, amount_due = 300000</li>
                                <li>Verify 1 payable line: SUPPLIER = 300000</li>
                                <li>Verify supplier_timeline_version = 1</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: B2B Affiliate Commission</div>
                            <ul>
                                <li>Emit ISSUED with affiliate data</li>
                                <li>partnerShareback.amount = 4694.2, taxes[0].amount = 516.36</li>
                                <li>Verify 3 payable lines: SUPPLIER, AFFILIATE_COMMISSION, TAX_WITHHOLDING</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Supplier Commission</div>
                            <ul>
                                <li>Emit ISSUED with supplier_commission</li>
                                <li>commission_type = "PERFORMANCE_BONUS", amount = 10000</li>
                                <li>Verify 2 payable lines: SUPPLIER + SUPPLIER_COMMISSION</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: Cancellation with Fee</div>
                            <ul>
                                <li>Initial ISSUED with commission/tax (v1)</li>
                                <li>Later emit CancelledWithFee (v2), cancellation_fee = 50000</li>
                                <li>Query effective payables: Baseline = 50000, commission/tax EXCLUDED</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Supplier Change (Rebooking)</div>
                            <ul>
                                <li>v1: ISSUED to Supplier A, amount_due = 300000</li>
                                <li>v2: ISSUED to Supplier B, amount_due = 320000</li>
                                <li>Verify both timeline versions stored immutably</li>
                                <li>Query latest: Supplier B with amount 320000</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Status-Driven Model Verification</div>
                            <ul>
                                <li>Setup: ISSUED (v1) with commission 5000</li>
                                <li>Action: Update to CancelledWithFee (v2)</li>
                                <li>Query: Verify commission excluded using get_total_effective_payables()</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 4: Refund Component Contract -->
                <tr>
                    <td class="requirement">Refund Component Contract to Handle Lineage - [Component Data - Refund Closed]</td>
                    <td class="user-story">
                        As an Order PM, I want to retrieve refund component data with complete lineage, so that it's easy to understand the complete pricing lifecycle
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Event Contract: RefundIssuedEvent</strong>
                            <ul>
                                <li><code>event_type</code>: "RefundIssued"</li>
                                <li><code>schema_version</code>: "refund.components.v1"</li>
                                <li><code>order_id</code>, <code>refund_id</code>, <code>emitted_at</code></li>
                                <li><code>components</code>: Array of PricingComponent with:
                                    <ul>
                                        <li><code>amount</code>: <strong>NEGATIVE value</strong> (refund amount)</li>
                                        <li><code>is_refund</code>: true (auto-detected)</li>
                                        <li><code>refund_of_component_semantic_id</code>: <strong>REQUIRED</strong> - Links to original</li>
                                        <li>Same dimensions as original component</li>
                                    </ul>
                                </li>
                                <li><code>detail_context</code>: FX context at refund time for FX gain/loss tracking</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Normalization (Order Core):</strong>
                            <ul>
                                <li>Assigns pricing_snapshot_id and version (continues from order's version sequence)</li>
                                <li>Validates refund_of_component_semantic_id exists</li>
                                <li>Auto-detects is_refund = true if refund_of_component_semantic_id present</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Storage:</strong>
                            <ul>
                                <li>Same <code>pricing_components_fact</code> table as regular components</li>
                                <li>is_refund flag = 1, refund_of_component_semantic_id populated</li>
                                <li>Queryable via semantic ID for lineage</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Semantic ID Generation (Refund-Specific):</strong>
                            <ul>
                                <li>Refund semantic ID format: <code>cs-{order_id}-{refund_id}-{dimensions}-{component_type}</code></li>
                                <li><strong>Key Difference</strong>: <code>refund_id</code> is embedded in semantic ID (unlike non-refund components)</li>
                                <li>Example: <code>cs-ORD-001-RFD-001-OD-001-BaseFare</code></li>
                                <li>Rationale: A single refund can be updated/corrected, creating multiple versions</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>"Latest" Projection Behavior (Differs from Non-Refund Components):</strong>
                            <ul>
                                <li><strong>Non-Refund Components</strong>: Latest determined by <code>(order_id, component_semantic_id)</code>
                                    <ul>
                                        <li>Takes MAX(version) per semantic ID</li>
                                        <li>One "latest" row per unique component type/dimensions</li>
                                    </ul>
                                </li>
                                <li><strong>Refund Components</strong>: Latest determined by <code>(component_semantic_id, refund_id)</code>
                                    <ul>
                                        <li>Refund ID extracted from semantic ID</li>
                                        <li>Takes latest version per refund_id</li>
                                        <li>One "latest" row per unique (refund_id, component_type, dimensions)</li>
                                    </ul>
                                </li>
                                <li><strong>Why This Matters</strong>: Prevents double-counting when a refund is corrected/updated
                                    <ul>
                                        <li>Example: RFD-001 initially refunds -200000 (v2), then corrected to -250000 (v3)</li>
                                        <li>Net calculation should use -250000 only (latest for RFD-001), not both versions</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Pydantic Models (v1.0.9):</div>
                            <ul>
                                <li><code>RefundIssuedEvent</code> in <code>events.py</code></li>
                                <li>Reuses <code>PricingComponent</code> with refund-specific fields</li>
                                <li>event_id made Optional (v1.0.9) - Order Core generates if missing</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Normalization (v1.0.9):</div>
                            <ul>
                                <li>Same dual ID generation (semantic + instance)</li>
                                <li>Lineage validation (refund_of_component_semantic_id must exist)</li>
                                <li>Assigns pricing_snapshot_id and version (continues order's version sequence)</li>
                                <li>Auto-detects is_refund = true if refund_of_component_semantic_id present</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Query Patterns:</div>
                            <ul>
                                <li>Query original component by semantic ID</li>
                                <li>Query refund components by refund_of_component_semantic_id</li>
                                <li>Aggregate net amount per semantic ID (original + refunds)</li>
                                <li>Component lineage tracing in Order Explorer</li>
                                <li><strong>Refund Projection</strong>: Extract refund_id from semantic ID (pattern: RFD-XXX), group refunds by refund_id, take latest version per refund_id (order_explorer.py:308-333)</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Test Coverage (v1.1.0):</div>
                            <ul>
                                <li>tests/test_refund_issued.py - Validates refund lineage works correctly</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Partial Refund</div>
                            <ul>
                                <li>Original BaseFare = 500000 (semantic ID: cs-ORD-001-BaseFare)</li>
                                <li>Refund 200000 of BaseFare with amount = -200000</li>
                                <li>Verify is_refund = 1, new pricing_snapshot_id and incremented version</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Full Refund Multiple Components</div>
                            <ul>
                                <li>Original: BaseFare 500000, Tax 50000</li>
                                <li>Refund both fully in single event</li>
                                <li>Verify both stored with same pricing_snapshot_id</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Lineage Query</div>
                            <ul>
                                <li>Query all components with semantic ID = "cs-ORD-001-BaseFare"</li>
                                <li>Result: v1 (500000, is_refund=0), v2 (-200000, is_refund=1)</li>
                                <li>Net amount = 300000</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3a: Refund Correction (Projection by refund_id)</div>
                            <ul>
                                <li>Initial: BaseFare = 500000 (v1, semantic: cs-ORD-001-BaseFare)</li>
                                <li>Refund issued: RFD-001 refunds -200000 (v2, semantic: cs-ORD-001-RFD-001-BaseFare)</li>
                                <li>Refund corrected: RFD-001 refunds -250000 (v3, semantic: cs-ORD-001-RFD-001-BaseFare)</li>
                                <li>Verify lineage net calculation groups by refund_id:
                                    <ul>
                                        <li>Latest original: 500000 (v1)</li>
                                        <li>Latest RFD-001: -250000 (v3) ← only latest version counted</li>
                                        <li>Net amount = 250000 (NOT 500000 - 200000 - 250000 = 50000)</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: FX at Refund</div>
                            <ul>
                                <li>Original booked at FX rate 1.0</li>
                                <li>Refund at FX rate 1.05 (IDR weakened)</li>
                                <li>detail_context.fx_context at refund has different rates</li>
                                <li>Calculate FX gain/loss</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Invalid Lineage</div>
                            <ul>
                                <li>Emit refund with refund_of_component_semantic_id = "nonexistent-id"</li>
                                <li>Validation fails → event sent to DLQ</li>
                                <li>Error type: VALIDATION_ERROR</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Refund-Only Order (Edge Case)</div>
                            <ul>
                                <li>Refund event arrives before any pricing event</li>
                                <li>Handle gracefully: DLQ or warn</li>
                                <li>Order Explorer should not crash on refund-only orders</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 5: Refund Lifecycle Contract -->
                <tr>
                    <td class="requirement">Refund Lifecycle Contract to Oversee Refund Lifecycle [Non-Component Data - Refund Status Updated]</td>
                    <td class="user-story">
                        As an Order PM, I want to ingest refund status into the pricing read layer, so that component lineage is connected with its lifecycle
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Event Contract: RefundLifecycleEvent</strong>
                            <ul>
                                <li><code>event_type</code>: REFUND_INITIATED, REFUND_CLOSED</li>
                                <li><code>schema_version</code>: "refund.timeline.v1"</li>
                                <li><code>order_id</code>, <code>refund_id</code>, <code>emitted_at</code></li>
                                <li><code>refund_timeline_version</code>: Monotonic version per refund_id</li>
                                <li><code>refund_amount</code>, <code>currency</code>, <code>refund_reason</code></li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Purpose:</strong>
                            <ul>
                                <li>Separate from RefundIssuedEvent (which contains components)</li>
                                <li>Tracks refund status progression: Initiated → Closed</li>
                                <li>Enables queries like "show all refunds for order_id"</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Storage:</strong>
                            <ul>
                                <li><code>refund_timeline</code> table</li>
                                <li>Indexed by order_id, refund_id</li>
                                <li>Versioned by refund_timeline_version</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Pydantic Models:</div>
                            <ul>
                                <li><code>RefundLifecycleEvent</code> in <code>events.py</code></li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Storage:</div>
                            <ul>
                                <li><code>refund_timeline</code> table</li>
                                <li>Separate from components table</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Query Methods:</div>
                            <ul>
                                <li>get_refund_timeline_by_order()</li>
                                <li>get_refund_timeline_by_refund_id()</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Refund Initiated</div>
                            <ul>
                                <li>Emit REFUND_INITIATED event</li>
                                <li>refund_amount = 200000, refund_reason = "Customer request"</li>
                                <li>Verify refund_timeline_version = 1</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Refund Closed</div>
                            <ul>
                                <li>Emit REFUND_CLOSED event for same refund_id</li>
                                <li>Verify refund_timeline_version = 2</li>
                                <li>Query timeline: verify 2 events for this refund</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Multiple Refunds per Order</div>
                            <ul>
                                <li>Order has 3 order_details, each with separate refund</li>
                                <li>Emit 3 separate refund lifecycle events</li>
                                <li>Verify 3 distinct refund_ids</li>
                                <li>Query by order_id: returns all 3 refunds</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: Timeline + Components Integration</div>
                            <ul>
                                <li>Refund timeline shows status progression</li>
                                <li>Refund components show amount breakdown</li>
                                <li>Join query: get refund status + component details</li>
                                <li>Verify consistency (timeline amount = sum of components)</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 6: Snapshot Versioning Assignment -->
                <tr>
                    <td class="requirement">Snapshot Versioning Assignment from Order (Event-Level)</td>
                    <td class="user-story">
                        As an Order PM, I want any component data to enter the layer immutably with snapshots per component and per order, so that I can track pricing evolution
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Version Key Assignment Rules:</strong>
                        </div>

                        <div class="criteria-section">
                            <strong>1. Pricing Snapshot Version (Components):</strong>
                            <ul>
                                <li>Producer event: PricingUpdatedEvent or RefundIssuedEvent</li>
                                <li>Order Core assigns: pricing_snapshot_id (UUID), version (monotonic per order_id)</li>
                                <li>Example: v1 (initial), v2 (partial refund), v3 (repricing), v4 (another refund)</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>2. Payment Timeline Version:</strong>
                            <ul>
                                <li>Producer event: PaymentLifecycleEvent</li>
                                <li>Order Core assigns: timeline_version (monotonic per order_id)</li>
                                <li>Example: v1 (Authorized), v2 (Captured), v3 (Refunded)</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>3. Supplier Timeline Version:</strong>
                            <ul>
                                <li>Producer event: SupplierLifecycleEvent</li>
                                <li>Order Core assigns: supplier_timeline_version (monotonic per order_detail_id)</li>
                                <li>Example: v1 (ISSUED to Supplier A), v2 (CancelledWithFee), v3 (ISSUED to Supplier B)</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>4. Refund Timeline Version:</strong>
                            <ul>
                                <li>Producer event: RefundLifecycleEvent</li>
                                <li>Order Core assigns: refund_timeline_version (monotonic per refund_id)</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Idempotency:</strong>
                            <ul>
                                <li>Producer can optionally provide event_id</li>
                                <li>Order Core validates: same event_id + order_id → skip processing</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Immutability:</strong>
                            <ul>
                                <li>No UPDATE operations on versioned tables</li>
                                <li>All changes are INSERT with new version</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Implementation:</div>
                            <ul>
                                <li><code>pipeline.py::ingest_event()</code> routes by event_type</li>
                                <li>Version retrieval: get_latest_pricing_version(), get_latest_payment_timeline_version(), get_latest_supplier_timeline_version()</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Storage Schema:</div>
                            <ul>
                                <li>All versioned tables have version column</li>
                                <li>Indexed for efficient latest-version queries</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Pricing Version Sequence</div>
                            <ul>
                                <li>Emit PricingUpdatedEvent → v1</li>
                                <li>Emit RefundIssuedEvent → v2</li>
                                <li>Emit PricingUpdatedEvent (repricing) → v3</li>
                                <li>Verify monotonic sequence 1, 2, 3</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Payment Version Independence</div>
                            <ul>
                                <li>Emit PricingUpdatedEvent → pricing v1</li>
                                <li>Emit PaymentLifecycleEvent → payment v1</li>
                                <li>Emit PaymentLifecycleEvent → payment v2</li>
                                <li>Verify payment versions independent of pricing versions</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Supplier Version per Order Detail</div>
                            <ul>
                                <li>Order has 2 order_details (OD-001, OD-002)</li>
                                <li>Emit for OD-001 → version 1</li>
                                <li>Emit for OD-002 → version 1 (independent counter)</li>
                                <li>Emit for OD-001 → version 2</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: Idempotency</div>
                            <ul>
                                <li>Emit PricingUpdatedEvent with event_id = "evt-001"</li>
                                <li>Re-emit same event with same event_id</li>
                                <li>Verify only 1 version created (v1)</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Concurrent Ingestion</div>
                            <ul>
                                <li>Simulate 2 events arriving simultaneously for same order</li>
                                <li>Both retrieve latest_version = 1</li>
                                <li>Handle race condition with retry or auto-increment</li>
                                <li>Verify final versions are (2, 3) not (2, 2)</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Immutability Verification</div>
                            <ul>
                                <li>Insert pricing v1</li>
                                <li>Attempt UPDATE on version 1 → should fail</li>
                                <li>Verify no UPDATE statements in codebase</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 7: Component Identity Assignment -->
                <tr>
                    <td class="requirement">Component Identity Assignment from Order (Component-Level)</td>
                    <td class="user-story">
                        As an Order System, I want to assign component-level identity both semantically and per snapshot, so that I can track component evolution and latest state
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Dual ID Strategy:</strong>
                        </div>

                        <div class="criteria-section">
                            <strong>1. Component Semantic ID:</strong>
                            <ul>
                                <li>Purpose: Stable logical identity for same component across versions</li>
                                <li>Construction: {order_id}-{dimensions_canonical}-{component_type}-{optional_meta_key}</li>
                                <li>Canonicalization: Sort dimension keys alphabetically</li>
                                <li>Example: 1325509981-1363607207-278791674-UPG-CGK-BaseFare</li>
                                <li>Disambiguation with meta key: For joint subsidies (tiket vs supplier)</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>2. Component Instance ID:</strong>
                            <ul>
                                <li>Purpose: Unique identifier per component occurrence in a snapshot</li>
                                <li>Construction: ci_{UUID} or hash-based</li>
                                <li>Uniqueness: One instance ID per (semantic_id, pricing_snapshot_id)</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Stability Properties:</strong>
                            <ul>
                                <li>Semantic ID is deterministic: Same logical component → Same semantic ID</li>
                                <li>Semantic ID is stable across repricing, refunds, order lifecycle</li>
                                <li>Instance ID is bound to semantic ID but unique per snapshot</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Refund Lineage:</strong>
                            <ul>
                                <li>refund_of_component_semantic_id MUST reference existing semantic ID from prior snapshot</li>
                                <li>Validation enforced during ingestion</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Implementation:</div>
                            <ul>
                                <li><code>id_generator.py::generate_dual_ids()</code> method</li>
                                <li>Canonicalization logic: sort dimensions by key</li>
                                <li>Hash-based semantic ID (SHA256) or readable format</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Storage:</div>
                            <ul>
                                <li><code>pricing_components_fact</code> table has component_semantic_id (indexed), component_instance_id (unique)</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Query Patterns:</div>
                            <ul>
                                <li>Latest by semantic: SELECT * WHERE component_semantic_id = X ORDER BY version DESC LIMIT 1</li>
                                <li>All history: SELECT * WHERE component_semantic_id = X ORDER BY version</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Semantic ID Stability</div>
                            <ul>
                                <li>v1: BaseFare with dimensions {order_detail_id: "OD-001", pax_id: "P1"}</li>
                                <li>Semantic ID = "cs-ORD-001-OD-001-P1-BaseFare"</li>
                                <li>v2: Repricing, same BaseFare dimensions</li>
                                <li>Verify SAME semantic ID across versions</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Instance ID Uniqueness</div>
                            <ul>
                                <li>v1: BaseFare semantic ID "cs-ORD-001-...", instance ID "ci_abc123"</li>
                                <li>v2: Same BaseFare semantic ID, instance ID "ci_def456" (DIFFERENT)</li>
                                <li>Verify 2 distinct instance IDs</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Canonicalization</div>
                            <ul>
                                <li>Vertical A: dimensions {pax_id: "P1", order_detail_id: "OD-001"}</li>
                                <li>Vertical B: dimensions {order_detail_id: "OD-001", pax_id: "P1"} (different order)</li>
                                <li>After canonicalization: both produce SAME semantic ID</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: Disambiguation with Meta</div>
                            <ul>
                                <li>Component 1: Subsidy -50000, meta.funding_source = "tiket"</li>
                                <li>Component 2: Subsidy -25000, meta.funding_source = "supplier"</li>
                                <li>Verify distinct semantic IDs: ...-Subsidy-tiket vs ...-Subsidy-supplier</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Order-Level Component</div>
                            <ul>
                                <li>Component: MDR Fee at order level, dimensions = {}</li>
                                <li>Semantic ID = "cs-ORD-001-Fee" (no granularity)</li>
                                <li>Verify semantic ID generated correctly</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Refund Lineage Validation</div>
                            <ul>
                                <li>Original: Semantic ID "cs-ORD-001-BaseFare"</li>
                                <li>Refund: refund_of_component_semantic_id = "cs-ORD-001-BaseFare"</li>
                                <li>Verify lineage link stored</li>
                                <li>Query: "Show all components linked to cs-ORD-001-BaseFare" → returns original + refund</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 7: Query Latest State</div>
                            <ul>
                                <li>v1: BaseFare 500000</li>
                                <li>v2: Refund -200000 (same semantic ID in refund_of)</li>
                                <li>Query latest by semantic ID: returns v1 original component</li>
                                <li>Query net amount: 500000 + (-200000) = 300000</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 8: Supplier Payable Lines -->
                <tr>
                    <td class="requirement">Supplier Payable Lines and Multi-Party Obligations [Supplier Payables - Multi-Party Breakdown]</td>
                    <td class="user-story">
                        As an Order PM and Finance team, I want supplier payables broken down by party and obligation type with flexible adjustments, so that we can track exact amounts owed to suppliers, affiliates, tax authorities, and handle real-world complexity at scale
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Event Contract 1: SupplierLifecycleEvent (v2)</strong>
                            <ul>
                                <li><code>event_type</code>: "SupplierLifecycleEvent"</li>
                                <li><code>schema_version</code>: "supplier.timeline.v2"</li>
                                <li><code>order_id</code>, <code>order_detail_id</code>, <code>emitted_at</code></li>
                                <li><code>supplier</code> (required nested object) with:
                                    <ul>
                                        <li><code>status</code>: "ISSUED", "Confirmed", "CancelledWithFee", "CancelledNoFee", etc.</li>
                                        <li><code>supplier_id</code>, <code>booking_code</code>, <code>supplier_ref</code></li>
                                        <li><code>amount_due</code>: Baseline amount owed to supplier</li>
                                        <li><code>amount_basis</code>: "gross" or "net" - clarifies if amount_due is pre or post commissions</li>
                                        <li><code>currency</code>, <code>fx_context</code>, <code>entity_context</code></li>
                                    </ul>
                                </li>
                                <li><code>parties</code> (optional array) - Multi-party obligations:
                                    <ul>
                                        <li>Each party has: <code>party_type</code>, <code>party_id</code>, <code>party_name</code></li>
                                        <li>Each party contains <code>lines</code> array with:
                                            <ul>
                                                <li><code>obligation_type</code>: SUPPLIER_COMMISSION_RETENTION, AFFILIATE_COMMISSION, TAX_VAT_ON_AFFILIATE_COMMISSION, etc.</li>
                                                <li><code>amount</code>: Amount of this obligation</li>
                                                <li><code>amount_effect</code>: "INCREASES_PAYABLE" or "DECREASES_PAYABLE"</li>
                                                <li><code>currency</code>, <code>calculation</code> (basis, rate), <code>description</code></li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li><code>idempotency_key</code>: (optional) For exactly-once processing</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Event Contract 2: PartnerAdjustmentEvent</strong>
                            <ul>
                                <li><code>event_type</code>: "PartnerAdjustmentEvent"</li>
                                <li><code>schema_version</code>: "partner.adjustment.v1"</li>
                                <li><code>order_id</code>, <code>order_detail_id</code>, <code>emitted_at</code></li>
                                <li><code>party</code> (required): party_type, party_id, party_name</li>
                                <li><code>line</code> (required): Single payable line with obligation_type, amount, amount_effect, calculation, description</li>
                                <li><strong>Purpose</strong>: Standalone adjustments (e.g., Salesforce SLA penalties) that persist regardless of supplier status changes</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Multi-Party Obligation Model:</strong>
                            <ul>
                                <li><strong>Timeline-Linked Obligations</strong> (supplier_timeline_version >= 1):
                                    <ul>
                                        <li>Created from <code>parties</code> array in SupplierLifecycleEvent</li>
                                        <li>Tied to supplier status lifecycle (ISSUED → Cancelled)</li>
                                        <li>When status changes to Cancelled*, empty parties array excludes these obligations</li>
                                    </ul>
                                </li>
                                <li><strong>Standalone Adjustments</strong> (supplier_timeline_version = -1):
                                    <ul>
                                        <li>Created from PartnerAdjustmentEvent</li>
                                        <li>Persist regardless of supplier status (always included in totals)</li>
                                        <li>Example: Salesforce SLA breach penalty, manual ops corrections</li>
                                    </ul>
                                </li>
                                <li><strong>Total Effective Payable</strong> = baseline (status-driven) + timeline obligations + standalone adjustments</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Status-Driven Baseline Logic:</strong>
                            <ul>
                                <li>ISSUED/Confirmed: baseline = amount_due</li>
                                <li>CancelledWithFee: baseline = cancellation_fee_amount (if provided in cancellation object)</li>
                                <li>CancelledNoFee: baseline = 0</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Normalization (Order Core):</strong>
                            <ul>
                                <li>Assigns <code>supplier_timeline_version</code> (monotonic per order_detail_id)</li>
                                <li>Expands parties array into individual <code>supplier_payable_lines</code> rows</li>
                                <li>Standalone adjustments stored with version = -1</li>
                                <li>Does NOT contain supplier_timeline_version in producer event (enrichment only)</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Backward Compatibility:</strong>
                            <ul>
                                <li>Support v1 schema: flat affiliate/supplier_commission fields (deprecated)</li>
                                <li>Support legacy schema_version: "supplier.timeline.v1" → auto-converts to v2 structure</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Pydantic Models (v2):</div>
                            <ul>
                                <li><code>SupplierLifecycleEvent</code> - With parties array and amount_basis</li>
                                <li><code>Party</code> - party_type, party_id, party_name, lines</li>
                                <li><code>PayableLine</code> - obligation_type, amount, amount_effect, calculation</li>
                                <li><code>PartnerAdjustmentEvent</code> - For standalone adjustments</li>
                                <li>Enums: <code>ObligationType</code>, <code>AmountEffect</code>, <code>AmountBasis</code></li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Normalization (v2):</div>
                            <ul>
                                <li><code>pipeline.py::_ingest_supplier_lifecycle_v2()</code> - Handles parties array</li>
                                <li><code>pipeline.py::_ingest_partner_adjustment()</code> - Standalone adjustments</li>
                                <li>Expands parties array → multiple supplier_payable_lines rows</li>
                                <li>Timeline-linked: version >= 1, Standalone: version = -1</li>
                                <li>Backward compatible with v1 schema (auto-converts)</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Storage Schema:</div>
                            <ul>
                                <li><code>supplier_timeline</code> - status, amount_due, amount_basis, cancellation fields</li>
                                <li><code>supplier_payable_lines</code> - Expanded from parties array with:
                                    <ul>
                                        <li>supplier_timeline_version (1+ for timeline, -1 for standalone)</li>
                                        <li>obligation_type, amount, amount_effect</li>
                                        <li>party_type, party_id, party_name</li>
                                        <li>calculation_basis, calculation_rate, calculation_description</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Query Methods:</div>
                            <ul>
                                <li><code>get_total_effective_payables()</code> - Status-driven total with amount_effect logic</li>
                                <li><code>get_payables_by_party()</code> - Aggregation by party_id</li>
                                <li><code>get_payables_timeline()</code> - Full audit trail</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Scenario A: Issued with Multi-Party Obligations</div>
                            <ul>
                                <li>Emit: SupplierLifecycleEvent (v2) with status=ISSUED, amount_due=1500000 (gross)</li>
                                <li>parties array contains:
                                    <ul>
                                        <li>SUPPLIER party: SUPPLIER_COMMISSION_RETENTION = -150000 (DECREASES_PAYABLE)</li>
                                        <li>AFFILIATE party: AFFILIATE_COMMISSION = +4694 (INCREASES_PAYABLE)</li>
                                        <li>AFFILIATE party: TAX_VAT_ON_AFFILIATE_COMMISSION = +516 (INCREASES_PAYABLE)</li>
                                    </ul>
                                </li>
                                <li>Query effective payables: Baseline 1500000 - 150000 + 4694 + 516 = 1355210 IDR</li>
                                <li>Verify: 3 party obligations stored, amount_effect applied correctly</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Scenario B: Cancelled with Empty Parties (Projection)</div>
                            <ul>
                                <li>v1: Issued with parties (total = 1355210)</li>
                                <li>v2: CancelledWithFee, parties = [] (empty), cancellation_fee = 50000</li>
                                <li>Query: Baseline = 50000, timeline obligations EXCLUDED (version >= 1)</li>
                                <li>Total = 50000 (no affiliate/tax, status changed)</li>
                                <li>Verify: Latest status drives payables, empty parties array excludes old obligations</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Scenario C: Standalone Penalty Persists</div>
                            <ul>
                                <li>v1: Issued with parties (total = 1355210)</li>
                                <li>v2: CancelledWithFee, parties = [], cancellation_fee = 50000</li>
                                <li>Emit: PartnerAdjustmentEvent for AFFILIATE_PENALTY = +500000 (v=-1)</li>
                                <li>Query: Baseline 50000 + standalone penalty 500000 = 550000</li>
                                <li>Verify: Standalone adjustments persist regardless of status changes</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Scenario D: Cancelled with Adjusted Affiliate</div>
                            <ul>
                                <li>v1: Issued with parties (includes affiliate commission)</li>
                                <li>v2: CancelledWithFee with NEW parties array containing adjusted affiliate amounts</li>
                                <li>Query: Baseline (cancellation_fee) + NEW adjusted affiliate obligations</li>
                                <li>Verify: New parties in v2 override v1 obligations for active status</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Amount Basis Clarity</div>
                            <ul>
                                <li>amount_basis = "gross": amount_due = 1000000, SUPPLIER_COMMISSION_RETENTION = -100000 (net supplier cost = 900000)</li>
                                <li>amount_basis = "net": amount_due = 900000 (already post-commission)</li>
                                <li>Verify: amount_basis field documented in supplier_timeline</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Payables by Party</div>
                            <ul>
                                <li>Query get_payables_by_party():</li>
                                <li>Party: supplier_id → total = 300000</li>
                                <li>Party: reseller_id → total = 4694</li>
                                <li>Party: tax_authority → total = 516</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Supplier Change</div>
                            <ul>
                                <li>v1: ISSUED to Supplier A (300000)</li>
                                <li>v2: CancelledNoFee (Supplier A obsolete)</li>
                                <li>v3: ISSUED to Supplier B (320000)</li>
                                <li>Query: Latest status = ISSUED (v3), Baseline = 320000</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 7: Payables Timeline Audit</div>
                            <ul>
                                <li>Query get_payables_timeline():</li>
                                <li>v1: SUPPLIER = 300000, AFFILIATE_COMMISSION = 5000</li>
                                <li>v2: (CancelledWithFee) no new lines</li>
                                <li>v=-1: AFFILIATE_PENALTY = 20000</li>
                                <li>Verify chronological order</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 9: DLQ -->
                <tr>
                    <td class="requirement">DLQ (Dead Letter Queue) for Failed Events [Error Handling]</td>
                    <td class="user-story">
                        As an Order System, I want failed events captured in DLQ with error details, so that we can debug and replay failed ingestions
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>DLQ Entry Structure:</strong>
                            <ul>
                                <li>dlq_id, event_id, order_id, event_type</li>
                                <li>error_type: VALIDATION_ERROR, SCHEMA_ERROR, PIPELINE_ERROR</li>
                                <li>error_message: Detailed error description</li>
                                <li>raw_event: Complete original event payload (JSON)</li>
                                <li>failed_at, retry_count, metadata</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Ingestion Flow:</strong>
                            <ol>
                                <li>Receive event</li>
                                <li>Try parse/validate (Pydantic)</li>
                                <li>If validation fails → DLQ with VALIDATION_ERROR</li>
                                <li>Try ingest (assign IDs, insert)</li>
                                <li>If ingestion fails → DLQ with PIPELINE_ERROR</li>
                            </ol>
                        </div>

                        <div class="criteria-section">
                            <strong>Retry Mechanism:</strong>
                            <ul>
                                <li>Manual retry via UI or API</li>
                                <li>Update retry_count on each attempt</li>
                                <li>Move to permanent failure after N retries</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Implementation:</div>
                            <ul>
                                <li><code>pipeline.py::_send_to_dlq()</code> method</li>
                                <li>Try-catch blocks around all ingestion logic</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">UI:</div>
                            <ul>
                                <li>Ingestion Console shows DLQ entries</li>
                                <li>Raw Data Storage viewer has DLQ tab</li>
                                <li>Retry button (future)</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Validation Error</div>
                            <ul>
                                <li>Emit PricingUpdatedEvent with missing order_id</li>
                                <li>Pydantic validation fails</li>
                                <li>Verify DLQ entry: error_type = VALIDATION_ERROR</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Schema Error</div>
                            <ul>
                                <li>Emit event with unknown event_type = "UnknownEvent"</li>
                                <li>Verify DLQ entry with SCHEMA_ERROR</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Pipeline Error</div>
                            <ul>
                                <li>Mock database failure during insert</li>
                                <li>Verify DLQ entry with PIPELINE_ERROR</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: Retry Success</div>
                            <ul>
                                <li>Event in DLQ due to temporary DB issue</li>
                                <li>DB issue resolved, retry event</li>
                                <li>Verify successful ingestion, DLQ entry resolved</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Monitoring</div>
                            <ul>
                                <li>Generate 100 failed events (mix of error types)</li>
                                <li>Query DLQ error type distribution</li>
                                <li>Verify alert triggered if threshold exceeded</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 10: Raw Data Storage Visualization -->
                <tr>
                    <td class="requirement">Raw Data Storage Visualization [Operational Visibility]</td>
                    <td class="user-story">
                        As an Operations/Engineering team, I want to view raw table contents after event ingestion, so that I can debug data flow and verify append-only architecture
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>UI Features:</strong>
                            <ul>
                                <li>Order Filter: Dropdown for "All Orders" or specific order_id, Refresh button</li>
                                <li>Table Tabs:
                                    <ol>
                                        <li>Pricing Components Fact (all columns, JSON formatted, refund highlighting, CSV export)</li>
                                        <li>Payment Timeline (timeline_version, status, amounts, instrument, CSV export)</li>
                                        <li>Supplier Timeline (supplier_timeline_version, status, amount, CSV export)</li>
                                        <li>Supplier Payable Lines (version = -1 highlighting with metrics, CSV export)</li>
                                        <li>Refund Timeline (refund_timeline_version, refund_amount, CSV export)</li>
                                        <li>DLQ (error_type breakdown chart, CSV export)</li>
                                    </ol>
                                </li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Display Features:</strong>
                            <ul>
                                <li>Horizontal scrolling for wide tables</li>
                                <li>Row count indicator</li>
                                <li>Pandas DataFrame rendering with column headers</li>
                                <li>JSON pretty-printing</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">✅ FULLY IMPLEMENTED:</div>
                            <ul>
                                <li><code>src/ui/raw_storage_viewer.py</code> module (complete)</li>
                                <li>Integrated into app.py navigation sidebar</li>
                                <li>Uses Streamlit dataframe component with st.dataframe()</li>
                                <li>All 6 tabs operational with CSV export</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Features Implemented:</div>
                            <ul>
                                <li>Order filter dropdown with "All Orders" option</li>
                                <li>Refresh button to reload data</li>
                                <li>Version = -1 highlighting in Supplier Payables tab</li>
                                <li>DLQ error type breakdown pie chart</li>
                                <li>JSON pretty-printing for metadata columns</li>
                                <li>Refund highlighting in Pricing Components tab</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Query Methods:</div>
                            <ul>
                                <li>Direct SQL SELECT * queries to all tables</li>
                                <li>Dynamic column extraction via cursor.description</li>
                                <li>Pandas DataFrame construction with proper headers</li>
                                <li>Row count indicators per tab</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: View Pricing Components</div>
                            <ul>
                                <li>Ingest order with 3 components</li>
                                <li>Navigate to Raw Data Storage → Pricing Components tab</li>
                                <li>Verify 3 rows with all columns visible</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Filter by Order</div>
                            <ul>
                                <li>Ingest 2 orders (ORD-001, ORD-002)</li>
                                <li>Select ORD-001 from dropdown</li>
                                <li>Verify only ORD-001 data displayed across all tabs</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Supplier Payables Highlighting</div>
                            <ul>
                                <li>Ingest supplier event with commission (v1)</li>
                                <li>Ingest penalty event (v=-1)</li>
                                <li>Verify metrics: Timeline-linked: 2, Standalone: 1</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: DLQ Visualization</div>
                            <ul>
                                <li>Ingest 5 failed events (3 validation, 2 schema errors)</li>
                                <li>Navigate to DLQ tab</li>
                                <li>Verify error type breakdown chart</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: CSV Export</div>
                            <ul>
                                <li>Navigate to any tab</li>
                                <li>Click "Download as CSV"</li>
                                <li>Verify CSV file downloaded with correct filename</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Refresh Functionality</div>
                            <ul>
                                <li>View Raw Data Storage for order</li>
                                <li>Ingest new event in background</li>
                                <li>Click Refresh button</li>
                                <li>Verify new data appears immediately</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 11: Order Explorer -->
                <tr>
                    <td class="requirement">Order Explorer - Computed Views [Consumer Interface]</td>
                    <td class="user-story">
                        As a CS agent or Finance analyst, I want computed order views showing latest pricing, payment status, and supplier info, so that I can quickly understand order state without manual aggregation
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Computed Views:</strong>
                        </div>

                        <div class="criteria-section">
                            <strong>1. Latest Pricing Breakdown:</strong>
                            <ul>
                                <li>Query latest components by semantic ID (not all historical versions)</li>
                                <li>Aggregate: Total by component_type, Net amount per semantic ID, Order total</li>
                                <li>Display: Component breakdown table, Total amount, Refund components highlighted</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>2. Payment Timeline:</strong>
                            <ul>
                                <li>Show progression: Authorized → Captured</li>
                                <li>Display: Latest status, Payment method + masked instrument, Amounts, BNPL schedule</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>3. Supplier Information:</strong>
                            <ul>
                                <li>Per order_detail_id: Latest supplier status, Supplier name/booking_code</li>
                                <li>Effective payables (status-driven calculation)</li>
                                <li>Breakdown by party (supplier, affiliate, tax)</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>4. Refund Summary:</strong>
                            <ul>
                                <li>Total refund amount, Refund timeline status, Refund components with lineage</li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>UI Layout:</strong>
                            <ul>
                                <li>Order selector dropdown</li>
                                <li>Tabs: Pricing | Payment | Supplier | Refunds</li>
                                <li>Summary metrics at top, Detailed breakdown tables below</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">✅ FULLY IMPLEMENTED:</div>
                            <ul>
                                <li><code>src/ui/order_explorer.py</code> module (complete)</li>
                                <li>Query methods: get_latest_pricing_by_semantic(), get_payment_timeline_latest(), get_supplier_effective_payables()</li>
                                <li>All 4 tabs operational: Pricing | Payment | Supplier | Refunds</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Aggregation Logic:</div>
                            <ul>
                                <li>Latest-only queries by semantic ID (not full history)</li>
                                <li>Net calculations for refunds (original + refund amounts)</li>
                                <li>Status-driven payables using ROW_NUMBER() window function</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">UI Enhancements (v1.0.2-1.0.8):</div>
                            <ul>
                                <li>v1.0.2: Fixed Latest Breakdown view to group by semantic ID correctly</li>
                                <li>v1.0.3: Added "Refund Of" column showing lineage in Latest Breakdown</li>
                                <li>v1.0.8: Rewritten Supplier Payables tab with status badges (🟢 Active, ⚪ Cancelled)</li>
                                <li>Currency formatting for zero-decimal currencies (IDR, JPY, KRW, VND)</li>
                                <li>Strike-through for cancelled suppliers with zero amount</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Pricing Breakdown</div>
                            <ul>
                                <li>Order with BaseFare 500000, Tax 50000</li>
                                <li>Verify breakdown: BaseFare: 500000, Tax: 50000, Total: 550000</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Pricing with Refund</div>
                            <ul>
                                <li>Original: BaseFare 500000, Refund: -200000</li>
                                <li>Verify: BaseFare net: 300000, Refund section shows -200000 linked</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Payment Status</div>
                            <ul>
                                <li>Authorized: 500000, Captured: 500000</li>
                                <li>Verify status = Captured, amount = 500000</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: Supplier Payables</div>
                            <ul>
                                <li>ISSUED: supplier 300000, commission 5000</li>
                                <li>Verify breakdown: Supplier: 300000, Affiliate: 5000, Total: 305000</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Cancelled Supplier</div>
                            <ul>
                                <li>ISSUED (v1): 300000 + commission 5000</li>
                                <li>CancelledWithFee (v2): fee 50000</li>
                                <li>Verify: Baseline: 50000, Commission excluded, Total: 50000</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Edge Case - Refund-Only Order</div>
                            <ul>
                                <li>Order has only refund components (no original pricing)</li>
                                <li>Verify: Warning displayed, Refund components shown, No crash</li>
                            </ul>
                        </div>
                    </td>
                </tr>

                <!-- Row 12: Multi-Order-Detail Support -->
                <tr>
                    <td class="requirement">Multi-Order-Detail Support (Option A) [Complex Order Handling]</td>
                    <td class="user-story">
                        As a Vertical PM, I want to send pricing for orders with multiple order_details in a single event, so that I can efficiently emit complex order pricing
                    </td>
                    <td class="acceptance-criteria">
                        <div class="criteria-section">
                            <strong>Option A Implementation:</strong>
                        </div>

                        <div class="criteria-section">
                            <strong>Event Structure:</strong>
                            <ul>
                                <li>Support BOTH:
                                    <ul>
                                        <li>detail_context (singular) - legacy, single order_detail</li>
                                        <li>detail_contexts (array) - new, multiple order_details</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>

                        <div class="criteria-section">
                            <strong>Matching Logic:</strong>
                            <ol>
                                <li>Build context map: order_detail_id → DetailContext</li>
                                <li>For each component: Extract order_detail_id from component.dimensions</li>
                                <li>Find matching context in map</li>
                                <li>Enrich component metadata with matched context (entity, FX)</li>
                            </ol>
                        </div>

                        <div class="criteria-section">
                            <strong>Benefits:</strong>
                            <ul>
                                <li>Single event for multi-detail orders (hotel multi-room, flight multi-pax)</li>
                                <li>Each order_detail can have different: Entity code, FX context</li>
                                <li>Backward compatible with single detail_context</li>
                            </ul>
                        </div>
                    </td>
                    <td class="implementation-notes">
                        <div class="impl-note">
                            <div class="note-label">Implementation:</div>
                            <ul>
                                <li><code>pipeline.py::_ingest_pricing_updated()</code> lines 98-107</li>
                                <li>Context map building</li>
                                <li>Component matching by order_detail_id</li>
                                <li>Metadata enrichment</li>
                            </ul>
                        </div>

                        <div class="impl-note">
                            <div class="note-label">Validation:</div>
                            <ul>
                                <li>Warn if component's order_detail_id not in context map</li>
                                <li>Allow unmatched (some components may not need context)</li>
                            </ul>
                        </div>
                    </td>
                    <td class="test-scenarios">
                        <div class="test-case">
                            <div class="test-case-title">Test Case 1: Single Order Detail (Legacy)</div>
                            <ul>
                                <li>Emit event with detail_context (singular)</li>
                                <li>3 components, all with same order_detail_id</li>
                                <li>Verify all components enriched with same context</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 2: Multi Order Detail (Option A)</div>
                            <ul>
                                <li>Emit event with detail_contexts array (2 contexts)</li>
                                <li>4 components: 2 for OD-001, 2 for OD-002</li>
                                <li>Verify each component matched to correct context</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 3: Partial Match</div>
                            <ul>
                                <li>detail_contexts has OD-001 only</li>
                                <li>Components have OD-001 and OD-002</li>
                                <li>Verify OD-001 enriched, OD-002 has minimal metadata</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 4: Different Entity per Detail</div>
                            <ul>
                                <li>OD-001: entity_code = "TNPL"</li>
                                <li>OD-002: entity_code = "GTN"</li>
                                <li>Components matched accordingly</li>
                                <li>Query by entity_code: returns correct subset</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 5: Different FX per Detail</div>
                            <ul>
                                <li>OD-001: supply_currency = "USD", fx_rate = 15000</li>
                                <li>OD-002: supply_currency = "SGD", fx_rate = 11000</li>
                                <li>Components enriched with different FX contexts</li>
                                <li>Verify FX calculation per component uses correct rate</li>
                            </ul>
                        </div>

                        <div class="test-case">
                            <div class="test-case-title">Test Case 6: Backward Compatibility</div>
                            <ul>
                                <li>Old producer sends detail_context (singular)</li>
                                <li>New ingestion logic supports both</li>
                                <li>Verify no breaking changes, context applied correctly</li>
                            </ul>
                        </div>
                    </td>
                </tr>

            </tbody>
        </table>
    </div>

    <!-- Implementation Summary Section -->
    <div style="margin-top: 3rem; padding: 2rem; background-color: var(--bg-card); border: 1px solid var(--border-color); border-radius: 8px;">
        <h2 style="color: var(--accent-green); margin-bottom: 1.5rem; font-size: 1.8rem;">✅ Implementation Status - v1.1.0</h2>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 2rem;">
            <div>
                <h3 style="color: var(--accent-blue); margin-bottom: 1rem;">Major Features Implemented</h3>
                <ul style="margin-left: 1.5rem; line-height: 1.8;">
                    <li><strong>Status-Driven Obligation Model (v1.0.8)</strong> - ROW_NUMBER() window function for smart baseline calculation</li>
                    <li><strong>Multi-Party Supplier Payables (v1.0.6)</strong> - SUPPLIER, AFFILIATE_COMMISSION, TAX_WITHHOLDING breakdown</li>
                    <li><strong>B2B Affiliate Support (v1.0.5)</strong> - Real production schema, CustomerContext, EntityContext, FXContext</li>
                    <li><strong>Raw Data Storage Viewer</strong> - Fully implemented with all 6 tabs, CSV export, filtering</li>
                    <li><strong>Rebooking Flow Support (v1.0.8)</strong> - Handles supplier changes seamlessly</li>
                    <li><strong>Test Suite Organization (v1.1.0)</strong> - All tests in tests/ directory, 100% passing</li>
                </ul>
            </div>

            <div>
                <h3 style="color: var(--accent-blue); margin-bottom: 1rem;">Key Enhancements & Fixes</h3>
                <ul style="margin-left: 1.5rem; line-height: 1.8;">
                    <li><strong>v1.0.9:</strong> Made event_id optional for refund events (Order Core generates if missing)</li>
                    <li><strong>v1.0.8:</strong> Added Cancellation support with fee_amount and fee_currency</li>
                    <li><strong>v1.0.7:</strong> Fixed affiliate/tax amounts (removed incorrect 100x multiplication for IDR)</li>
                    <li><strong>v1.0.3:</strong> Added "Refund Of" column to Latest Breakdown view</li>
                    <li><strong>v1.0.2:</strong> Fixed Latest Breakdown view to group by semantic ID correctly</li>
                    <li><strong>Currency Handling:</strong> Zero-decimal currency support (IDR, JPY, KRW, VND)</li>
                </ul>
            </div>
        </div>

        <div style="margin-top: 2rem;">
            <h3 style="color: var(--accent-blue); margin-bottom: 1rem;">Test Coverage (v1.1.0)</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
                <div style="background-color: rgba(88, 166, 255, 0.1); padding: 1rem; border-radius: 4px;">
                    <strong>tests/test_b2b_real_files.py</strong><br/>
                    <span style="color: var(--text-secondary);">B2B affiliate integration with real production data</span>
                </div>
                <div style="background-color: rgba(88, 166, 255, 0.1); padding: 1rem; border-radius: 4px;">
                    <strong>tests/test_rebooking_flow.py</strong><br/>
                    <span style="color: var(--text-secondary);">Status-driven obligations and supplier rebooking</span>
                </div>
                <div style="background-color: rgba(88, 166, 255, 0.1); padding: 1rem; border-radius: 4px;">
                    <strong>tests/test_refund_issued.py</strong><br/>
                    <span style="color: var(--text-secondary);">Refund lineage and component tracking</span>
                </div>
                <div style="background-color: rgba(88, 166, 255, 0.1); padding: 1rem; border-radius: 4px;">
                    <strong>tests/test_payment_fee_scenario.py</strong><br/>
                    <span style="color: var(--text-secondary);">Payment fees and timeline progression</span>
                </div>
                <div style="background-color: rgba(88, 166, 255, 0.1); padding: 1rem; border-radius: 4px;">
                    <strong>tests/test_b2b_affiliate.py</strong><br/>
                    <span style="color: var(--text-secondary);">Manual B2B affiliate flow testing</span>
                </div>
                <div style="background-color: rgba(63, 185, 80, 0.1); padding: 1rem; border-radius: 4px; border: 2px solid var(--accent-green);">
                    <strong>✅ All Tests Passing</strong><br/>
                    <span style="color: var(--accent-green);">100% test success rate</span>
                </div>
            </div>
        </div>

        <div style="margin-top: 2rem; padding: 1rem; background-color: rgba(63, 185, 80, 0.1); border-left: 4px solid var(--accent-green); border-radius: 4px;">
            <strong style="color: var(--accent-green);">Production Readiness:</strong>
            <span style="color: var(--text-primary);">
                All 12 requirements fully implemented and tested. Core patterns validated with real production data.
                Ready for stakeholder demonstrations and production implementation planning.
            </span>
        </div>
    </div>

    <footer style="text-align: center; padding: 2rem; color: var(--text-secondary); border-top: 1px solid var(--border-color); margin-top: 3rem;">
        <p><strong>Unified Order Pricing Read Layer</strong> - Enhanced PRD v2.1</p>
        <p style="color: var(--accent-green); margin-bottom: 1rem;">✅ Updated for Prototype v1.1.0 Implementation (2025-11-10)</p>
        <p style="margin-bottom: 0.5rem;">Generated from comprehensive prototype implementation analysis</p>
        <p style="font-size: 0.9em; margin-top: 1rem;">
            <strong>Key Updates:</strong> Status-driven obligation model (v1.0.8), Multi-party supplier payables (v1.0.6),
            B2B affiliate support (v1.0.5), Raw Data Storage Viewer (fully implemented), Currency handling enhancements,
            Test suite organization (v1.1.0), Bug fixes for affiliate/tax amounts (v1.0.7)
        </p>
        <p style="font-size: 0.9em; margin-top: 0.5rem;">
            <strong>Test Files:</strong> tests/test_b2b_real_files.py, tests/test_rebooking_flow.py,
            tests/test_refund_issued.py, tests/test_payment_fee_scenario.py, tests/test_b2b_affiliate.py
        </p>
    </footer>
</body>
</html>