Requirement	User Story	Acceptance Criteria
Standardized Pricing Event Schema – [Component Data - Vertical Initiated]	User Story As a Vertical PMs/Component Owners  I want to be able to share detailed pricing breakdown for a separate concern (specialized pricing store) in a standardized manner So that later on it will be easy for everyone to understand what constitute an Order even for multiple repricing or operational events	Define a single event contract that all verticals must use when publishing pricing data (time will coincide order creation, rebooking, relocation). This contract must capture Order identification: order_id, vertical, created_at/emitted_at  Customer context: reseller_type_name → B2C, B2B_AFFILIATE, B2B_CORPORATE etc  reseller_name → partner name  reseller_id  account_id   Vertical must provide detail context to elaborate the data sent by them such as: order detail id,  supplier → the provider of that inventory  entity code (as of now we have 2 business entities (Global Tiket Network /GTN and Tiket Network Pte Ltd /TNPL)  FX Context: timestamp fx rate  payment currency  supply currency  record currency  gbv currency  payment value  supply to payment fx rate  supply to record fx rate  payment to gbv fx rate    This structure of this data is to support fact that FX context and entity is applicable at order detail id level because different order detail ids within one order id can be fulfilled by different supplier thus have different supply currency and fx context between one and another  Component breakdown: type, amount, currency  Dimensions specific to vertical (rate granularity that vertical is using when sending the breakdown): order_detail_id, passenger, segment, room, night, etc. Dimension will provide clarity on what level of granularity that one component is used by emitter.  Example: if a component’s dimension only has order_detail_id value, then that specific component’s value is applicable throughout order detail id linked.  For the case where component is applicable to the whole order_id instead of deeper granularity then no dimension is needed   vertical-specific extensions allowed via meta fields only either per component level or order_id level (root) . Example: vertical wants to put funding source for a price deducting component (e.g member deals where fund source is on vendor/supplier), then for member deals component, vertical can put meta.funding_source as supplier so that consumer can easily digest the information
Payment Lifecycle Information - [Non-Component Data - Payment initiated]	As Order PM I want a single versioned payment timeline  So that the system always know the latest payment state even across multiple partial captures or refund so that it can cater clarity of payment state and issued state because of the separation (Goal is to differentiate “issued but not paid”, “issued but partially paid”, “paid and issued”, and “paid and not issued”)	Need payment team to send information related to order payments within 2 states: Check-out: When paymode has been finalized and state is waiting for payment  Captured: when user paid   During checkout, payment will need to capture at least order_id,  created_at,  updated_at,  currency,  payment.payment_status,  payment.payment_id,  payment.payment_method,  payment.authorized_amount → total amount that needs to be paid by the user (invoice amount)  payment.authorized_at → checkout time  payment.due_at → expiry time  payment.captured_at → empty because no payment has been made from the user  payment.captured_amount → 0 because no payment has been made from the user  for any BNPL method (downpay, flex payment), payment will need to capture the plan that consist of bnpl type (either downpay, flex payment, pay_later etc)  installment_tenor  currency  total principal  fees (provision, extra fee)  schedules containing:  installment sequence,   due date,   principal due,   fee due,   captured amount,   captured at    the schedule will reflect its state accordingly    During settlement (payment capture) Payment will need to capture order_id,  created_at,  updated_at,  currency,  payment.payment_status,  payment.payment_id,  payment.payment_method,  payment.payment_entity_number, → cc number/VA number etc  payment.authorized_amount → total amount that needs to be paid by the user (invoice amount)  payment.authorized_at → checkout time  payment.captured_at → latest timestamp payment is done by user  payment.captured_amount →  running sum of payment performed by user (for pay later) for non paylater simply payment amount by user  payment.payment_gateway_name or payment psp name → the payment service provider OR payment gateway name  instrument.  for any BNPL method (downpay, flex payment), payment will need to capture the plan that consist of bnpl type (either downpay, flex payment, pay_later etc)  installment_tenor  currency  total principal  schedules containing: installment sequence, due date, principal due, fee due, captured amount, captured at   the schedule will reflect its state accordingly
Issuance/Supplier Lifecycle Handling [Non-Component Data - Refund Initiated]	As an Order PM I want to be able to retrieved issuance detailed data stored in the layer  So that we have supplier booking data and handling its lineage if there’s changes	During issuance, vertical needs to send data that captures order id,  order detail id,  issued at  supplier order data i.e: booking status in supplier side  supplier name  booking code (supplier booking identifier for customer)  supplier ref code (supplier booking identifier for tiket.com) (may be the same with booking code)  amount → amount due to supplier  due_at  currency  fx_context supply currency,  customer payment currency  supply to payment fx rate  timestamp fx rate    entity code  commission data (optional) – this is not price component data but rather stateful fact, so we don’t need semantic id. If supplier changes, the old payable and commission are obsolete, not evolutive currency  amount  commission rate    Vertical needs to make sure every time new booking to supplier is confirmed, vertical needs to provide the supplier data along with issuance lifecycle data  Any other pass-through information to consumer can be stored within meta data
Refund Component Contract to Handle Lineage - [Component Data - Refund Closed]	As an Order PM, I want to be able to retrieve refund component data stored in this pricing layer with complete lineage So that it’s easy to understand complete lineage of an order pricing lifecycle	Define a single event contract same with what vertical send but triggered from refund to document refund prices component in which also captures Refund must provide detail context to elaborate the data sent by them such as: order detail id,  supplier → the provider of that inventory  entity code (as of now we have 2 business entities (Global Tiket Network /GTN and Tiket Network Pte Ltd /TNPL)  FX Context (expectedly fx effective per refund is emitted) timestamp fx rate  payment currency  supply currency  record currency  gbv currency  payment value  supply to payment fx rate  supply to record fx rate  payment to gbv fx rate     Refund also must send components that link back to original component for consumer to trace. Which original components are being refunded (lineage)  Refund amount per component (negative amount)  refund reason and refund ID  refund and disbursement status  FX rates at refund initiation and settlement (for FX gain/loss tracking)   Refund data from refund service must include refund of component semantic id field linking to original component.  Refund team responsibility:  Provide data of refund pricing items during refund closed status with refund status flag  decide which commercial charge(s) are being reversed and reference them.   Refund needs to capture the FX context with fx rate effective at disbursement/closed status: timestamp fx rate  payment currency  supply currency  record currency  gbv currency  paymentValue  supply to payment fx rate  supply to record fx rate  payment to gbv fx rate
Refund Lifecycle Contract to oversee refund lifecycle [Non-Component Data - Refund Status Updated]	As an Order PM, I want to be able to ingest the refund status into the pricing read layer   So that component lineage can be connected with its lifecycle	Refund will need to send information that captures at least order_id,  order_detail_id,  refund_id,  refund status  created_at  updated_at  any additional information to send to the layer   This event is not capturing price component but rather an additional information to complete lineage of an order so consumer of layer will understand the state that happen to an order_detail or item level (L3)  Expectation is for refund to send the data upon refund status update
Snapshot Versioning Assignment from Order (Event-Level)	As an Order PM, I want to be able to let any components data to enter the layer to be stored immutably with snapshots per component and per order So that I can track the pricing evolution of an order within its lifecycle	In response to incoming data from component owners, order must assign version keys to keep data immutable but having lineage.  There will be 4 types of events. Components, Payment Lifecycle/Timeline, Supplier Timeline, Refund Timeline  For Components Events (Pricing and Refund Component), order needs to assign: pricing snapshot id: unique ID for each pricing event  version: increment increasing number per order (v1,v2,v3, …)  Example of pricing evolution v1: initial booking pricing  v2: partial refund components appended  v3: another partial refund components appended    For Payment Lifecycle/Timeline events, order needs to assign payment timeline version: increment increasing number per order id  Each of version will carry the truth of timeline including the state of payment for universal payment method (installment vs non-installments, partial capture/full capture/ not captured (bnpl) separated from the pricing and supplier events   For supplier timeline events (Issuance), order needs to assign supplier timeline version: increment increasing number per order detail  This can provide truth to consumer even if one same order detail undergoes supplier changes (payable change)   Previously created snapshot remain immutable  This enriched data will be passed to the storage read layer  Make sure that same detail idempotence is validated before assigning version
Component Identity assignment from Order (component-level)	As an Order System, I want to be able to assign component-level identity both semantically and per snapshot occurrence  So that i am always be able to see same components across version consistently AND i am able to see the identity of semantic component each time they appear in the snapshot (to see component’s evolution)	On component level, order need to assign two types of IDs component semantic ID: stable logical identity (e.g: “Base Fare for Passenger Adult 1 on Segment CGK-SIN) → this semantic component will be used for the case of repricing or refunds down the line)  component instance ID: the unique identifier per component semantic id and pricing snapshot Main reason to have this: some queries will ask latest-by-semantic not only complete historical audit trail. Having specific instance id per component will ease the retrieval and identification of latest state of each component.    Component semantic ID construction logic: {order_id}-{dimensions in canonical order}-{component type}-{optional component key(meta)} Example: 1325509981-1363607207-278791674-UPG-CGK-BaseFare This happens if initially flight sends us event where one of the components has this detail order_id = 1325509981 (event-level)  component dimension of granularity  order_detail_id = 1363607207  profile_id = 278791674  segment = UPG-CGK  component_type = BaseFare     Why does canonicalization matter? Some vertical may send dimension in different lexicographical format although semantically the same. Impact? It may be assigned as different component.  There’s also cases where order_id, dims, component type is the same (granularity is the same) but will behave differently. Example is joint subsidy: Example there’s subsidy 1325509981-1363607207-278791674-UPG-CGK-Subsidy = -50000 (from tiket side)  and there’s 1325509981-1363607207-278791674-UPG-CGK-Subsidy = -25000 (from supplier side)  If this case happen, vertical will need to send meta so that it can be incorporated into component id    Semantic IDs are deterministic (same logical component → same ID)  Semantic IDs are stable across repricing, refund, or order price lifecycle (v1 and v2 have same semantic ID for unchanged components)  Instance IDs are bound to a semantic ID but unique per snapshot  Refund events will link to original via refund_of_component_semantic_id Refund lineage: refund_of_component_semantic_id must reference an existing semantic ID in a prior snapshot for the same order.