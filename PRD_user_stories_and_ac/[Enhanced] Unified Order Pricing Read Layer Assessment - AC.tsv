Requirement	User Story	Acceptance Criteria	Implementation Notes	Test Scenarios
Standardized Pricing Event Schema – [Component Data - Vertical Initiated]	As a Vertical PM/Component Owner, I want to share detailed pricing breakdown for a specialized pricing store in a standardized manner, so that everyone can understand what constitutes an Order across multiple repricing or operational events	**Event Contract Structure:**
- Define single event contract: `PricingUpdated` with schema version `pricing.commerce.v1`
- Event must include:
  * `event_id` (optional - Order Core generates if missing)
  * `event_type`: "PricingUpdated"
  * `order_id`: Order identifier
  * `vertical`: (optional) e.g., "accommodation", "flight"
  * `emitted_at`: ISO8601 timestamp
  * `emitter_service`: (optional) producing service name

**Customer Context (B2B scenarios):**
- `customer_context` object with:
  * `reseller_type_name`: "B2C", "B2B_AFFILIATE", "B2B_CORPORATE"
  * `reseller_id`: Partner identifier
  * `reseller_name`: Partner display name

**Detail Context (Multi-Order-Detail Support - Option A):**
- Support BOTH:
  * `detail_context` (legacy): Single context for backward compatibility
  * `detail_contexts` (new): Array of contexts for multiple order_details
- Each context contains:
  * `order_detail_id`: Unique detail identifier
  * `entity_context`:
    - `entity_code`: "GTN", "TNPL"
    - `merchant_of_record`: (optional) Multi-entity format
    - `supplier_entity`: (optional)
    - `customer_entity`: (optional)
  * `fx_context` (if multi-currency):
    - `timestamp_fx_rate` or `as_of`: FX rate effective timestamp
    - `payment_currency`, `supply_currency`, `record_currency`, `gbv_currency`
    - `payment_value`: Amount in payment currency
    - `supply_to_payment_fx_rate`, `supply_to_record_fx_rate`, `payment_to_gbv_fx_rate`
    - `source`: e.g., "Treasury"

**Component Breakdown:**
- `components`: Array of pricing components with:
  * `component_type`: Union[ComponentType enum, string]
    - Enum values: BaseFare, RoomRate, Tax, Subsidy, Discount, Fee, Markup, CancellationFee, AmendmentFee, Refund, Compensation, AffiliateShareback, VAT
    - Support custom string for extensibility
  * `amount`: Union[int, float] - smallest currency unit or decimal
  * `currency`: Currency code
  * `dimensions`: Dict[str, str] - Granularity indicators
    - Examples: {"order_detail_id": "OD-001", "pax_id": "P1", "segment": "CGK-SIN"}
    - If only order_id level, dimensions may be empty or minimal
  * `description`: (optional) Human-readable description
  * `is_refund`: (optional) Boolean flag - producer can set explicitly
  * `refund_of_component_semantic_id`: (optional) Lineage pointer for refunds
  * `meta` or `metadata`: (optional) Vertical-specific extensions
    - Example: funding_source, promo_code, policy_type

**Totals Validation:**
- `totals` (optional but recommended):
  * `customer_total`: Expected sum of components
  * `currency`: Currency code
- Order Core validates sum matches within epsilon	**Pydantic Models:**
- `PricingUpdatedEvent` in `events.py`
- `PricingComponent` with Union types
- `DetailContext` with `entity_context` and `fx_context`
- `CustomerContext` for B2B

**Normalization Logic:**
- `pipeline.py::_ingest_pricing_updated()`
- Context map building (line 100-107)
- Dual ID generation per component
- Metadata enrichment with matched context

**Storage:**
- `pricing_components_fact` table
- All component fields + enrichment
- JSON columns: dimensions, metadata	**Test Case 1: Single Order Detail**
- Vertical emits event with `detail_context` (singular)
- All components have same `order_detail_id` in dimensions
- Verify context applied to all components

**Test Case 2: Multi Order Detail (Option A)**
- Vertical emits event with `detail_contexts` (array)
- Components have different `order_detail_id` values
- Verify each component matched to correct context
- Verify metadata includes entity_context/fx_context per match

**Test Case 3: B2B Affiliate Context**
- Event includes `customer_context` with reseller info
- Verify stored in component metadata
- Query by reseller_id succeeds

**Test Case 4: Component Type Extensibility**
- Send custom component_type string (e.g., "LoyaltyPoints")
- Verify ingestion succeeds (Union[ComponentType, str])
- Verify retrieval returns custom type

**Test Case 5: Totals Validation**
- Send event with `totals.customer_total` = 100000
- Components sum to 100000 → Success
- Components sum to 99999 → Warning logged, ingestion succeeds

**Test Case 6: Empty Dimensions**
- Order-level component (no granularity)
- dimensions = {} or minimal
- Verify semantic ID generation succeeds
Payment Lifecycle Information - [Non-Component Data - Payment initiated]	As an Order PM, I want a single versioned payment timeline, so that the system always knows the latest payment state across multiple partial captures or refunds, enabling clarity between "issued but not paid", "paid and issued", etc.	**Event Contract: PaymentLifecycleEvent**
- `event_type`: "PaymentLifecycle"
- `schema_version`: "payment.timeline.v1"
- `order_id`: Order identifier
- `emitted_at`: ISO8601 timestamp
- `payment` (required nested object):
  * `status`: "Authorized", "Captured", "Refunded", "Settled"
  * `payment_id`: Payment intent ID (displayed as "Intent ID" in UI)
  * `pg_reference_id`: Payment gateway reference (displayed as "PG Reference")
  * `payment_method`: Object with:
    - `channel`: e.g., "CC", "VA", "AFFILIATE_DEPOSIT"
    - `provider`: e.g., "Stripe", "AffiliateDeposit"
    - `brand`: e.g., "VISA", "INTERNAL"
  * `currency`: Payment currency
  * `authorized_amount`: (optional) Total invoice amount
  * `authorized_at`: (optional) Checkout timestamp
  * `captured_amount`: (optional) Amount captured in THIS event
  * `captured_amount_total`: (optional) Running total of all captures
  * `captured_at`: (optional) Latest payment timestamp
  * `instrument`: (optional) Masked payment instrument with:
    - `type`: "VA", "CARD", "EWALLET", "BNPL", "QR"
    - `va`: (optional) {"bank": "BNI", "account_number_masked": "8060•••1234"}
    - `card`: (optional) {"last4": "1234", "brand": "VISA", "exp_month": 12}
    - `ewallet`: (optional) {"provider": "GOPAY", "phone_masked": "0812•••789"}
    - `bnpl`: (optional) {"provider": "KREDIVO", "contract_id": "KRD-123"}
    - `display_hint`: (optional) e.g., "BNI VA ••••1234"
    - `psp_ref`: (optional) PSP reference
    - `psp_trace_id`: (optional) PSP trace ID
  * `bnpl_plan`: (optional) For BNPL-specific data:
    - `bnpl_type`: "downpay", "flex_payment", "pay_later"
    - `installment_tenor`: Number of installments
    - `total_principal`: Principal amount
    - `schedules`: Array of installment schedules with:
      + `installment_sequence`: 1, 2, 3, ...
      + `due_date`: ISO8601
      + `principal_due`: Amount
      + `fee_due`: Fee amount
      + `captured_amount`: (optional) Amount paid for this installment
      + `captured_at`: (optional) Payment timestamp
- `idempotency_key`: (optional) For exactly-once processing
- `meta`: (optional) Additional metadata

**Backward Compatibility:**
- Support legacy flat structure (deprecated):
  * `payment_method` (string)
  * `amount`, `currency`, `pg_reference_id` at root level

**Normalization (Order Core):**
- Assigns `timeline_version` (monotonic per order_id)
- Does NOT contain `timeline_version` in producer event (enrichment only)	**Pydantic Models:**
- `PaymentLifecycleEvent` in `events.py`
- `Payment` nested object
- `PaymentMethod`, `PaymentInstrument` classes

**Normalization:**
- `pipeline.py::_ingest_payment_lifecycle()`
- Extracts nested `payment` object OR legacy flat
- Assigns `timeline_version`

**Storage:**
- `payment_timeline` table
- JSON columns: instrument, bnpl_plan, metadata
- Timeline version indexed	**Test Case 1: Authorized Event**
- Payment emits event with `status` = "Authorized"
- `authorized_amount` = 500000
- `authorized_at` populated
- `captured_amount` = 0
- Verify `timeline_version` = 1

**Test Case 2: Captured Event (Full)**
- Payment emits event with `status` = "Captured"
- `captured_amount` = 500000
- `captured_amount_total` = 500000
- Instrument masked correctly
- Verify `timeline_version` = 2

**Test Case 3: Partial Capture**
- First capture: `captured_amount` = 200000, `captured_amount_total` = 200000 → v3
- Second capture: `captured_amount` = 300000, `captured_amount_total` = 500000 → v4
- Query latest: verify `captured_amount_total` = 500000

**Test Case 4: BNPL with Schedules**
- `bnpl_plan.schedules` has 3 installments
- Schedule[0]: captured_amount = 100000 (downpay)
- Schedule[1], [2]: captured_amount = null (pending)
- Verify JSON storage and retrieval

**Test Case 5: Instrument Masking**
- VA: account_number_masked contains "•••"
- Card: last4 only, no full PAN
- EWallet: phone_masked with "•••"
- Verify no sensitive data stored

**Test Case 6: Idempotency**
- Emit same event twice with same `idempotency_key`
- Verify only one row inserted
- Verify no duplicate `timeline_version`
Issuance/Supplier Lifecycle Handling [Non-Component Data - Supplier Initiated]	As an Order PM, I want to retrieve detailed supplier/issuance data with its lineage if there are changes, so that we have complete supplier booking history	**Event Contract: SupplierLifecycleEvent**
- `event_type`: "IssuanceSupplierLifecycle" or similar
- `schema_version`: "supplier.timeline.v1"
- `order_id`: Order identifier
- `order_detail_id`: Detail identifier
- `emitted_at`: ISO8601 timestamp
- `supplier` (required nested object):
  * `status`: "ISSUED", "Confirmed", "CancelledNoFee", "CancelledWithFee", "Invoiced", "Settled", "Voided"
  * `supplier_id`: Supplier identifier
  * `booking_code`: (optional) Supplier booking ID for customer
  * `supplier_ref`: (optional) Supplier booking ID for Tiket.com
  * `amount_due`: (optional) Baseline amount owed to supplier
  * `currency`: (optional) Currency code
  * `fx_context`: (optional) FX details at supplier level
  * `entity_context`: (optional) Entity details
  * `affiliate`: (optional) For B2B affiliate cases:
    - `reseller_id`, `reseller_name`
    - `partnerShareback`: Commission object with:
      + `component_type`: "AffiliateShareback"
      + `amount`: Commission amount (can be decimal)
      + `currency`: Currency code
      + `rate`: e.g., 0.1 for 10%
      + `basis`: e.g., "markup"
    - `taxes`: Array of tax objects:
      + `type`: "VAT"
      + `amount`: Tax amount
      + `currency`: Currency code
      + `rate`: e.g., 0.11 for 11%
      + `basis`: e.g., "shareback"
  * `supplier_commission`: (optional) Commission paid TO supplier:
    - `commission_type`: "PERFORMANCE_BONUS", "REFERRAL_FEE", "VOLUME_INCENTIVE"
    - `amount`: Commission amount (decimal)
    - `currency`: Currency code
    - `rate`: (optional) Commission rate
    - `basis`: (optional) e.g., "supplier_cost"
    - `description`: (optional) Description
  * `cancellation`: (optional) For cancelled orders:
    - `fee_amount`: Cancellation fee
    - `fee_currency`: Currency code
- `idempotency_key`: (optional)
- `meta`: (optional) Pass-through information

**Normalization (Order Core):**
- Assigns `supplier_timeline_version` (monotonic per order_detail_id)
- Creates payable lines in `supplier_payable_lines` table:
  * SUPPLIER obligation (baseline)
  * AFFILIATE_COMMISSION (if affiliate exists)
  * TAX_WITHHOLDING (if affiliate taxes exist)
  * SUPPLIER_COMMISSION (if supplier_commission exists)

**Status-Driven Obligation Model:**
- Latest supplier status determines effective baseline:
  * ISSUED/Confirmed: `amount_due` is baseline
  * CancelledWithFee: `cancellation_fee_amount` is baseline, EXCLUDE commission/tax
  * CancelledNoFee: 0 baseline, EXCLUDE commission/tax
- Adjustments (version = -1) ALWAYS included regardless of status	**Pydantic Models:**
- `SupplierLifecycleEvent` in `events.py`
- `Supplier` nested object
- `Affiliate`, `SupplierCommission`, `Cancellation` classes

**Normalization:**
- `pipeline.py::_ingest_supplier_lifecycle()`
- Assigns `supplier_timeline_version`
- Creates multiple payable lines

**Storage:**
- `supplier_timeline` table (status progression)
- `supplier_payable_lines` table (multi-party breakdown)
- `obligation_type` field: SUPPLIER, AFFILIATE_COMMISSION, TAX_WITHHOLDING, SUPPLIER_COMMISSION

**Query Methods:**
- `get_supplier_timeline_by_detail()`
- `get_payables_by_party()` (raw aggregation)
- `get_total_effective_payables()` (status-aware)
- `get_payables_timeline()` (audit trail)	**Test Case 1: Initial Issuance**
- Vertical emits ISSUED status
- `amount_due` = 300000
- No affiliate, no supplier commission
- Verify 1 payable line: SUPPLIER = 300000
- Verify `supplier_timeline_version` = 1

**Test Case 2: B2B Affiliate Commission**
- Emit ISSUED with `affiliate` data
- `partnerShareback.amount` = 4694.2, `rate` = 0.1
- `taxes[0].amount` = 516.36, `rate` = 0.11
- Verify 3 payable lines:
  * SUPPLIER = 300000
  * AFFILIATE_COMMISSION = 4694 (rounded)
  * TAX_WITHHOLDING = 516
- All have same `supplier_timeline_version`

**Test Case 3: Supplier Commission**
- Emit ISSUED with `supplier_commission`
- `commission_type` = "PERFORMANCE_BONUS"
- `amount` = 10000, `rate` = 0.04
- Verify 2 payable lines:
  * SUPPLIER = 300000
  * SUPPLIER_COMMISSION = 10000

**Test Case 4: Cancellation with Fee**
- Initial ISSUED with commission/tax (v1)
- Later emit CancelledWithFee (v2)
- `cancellation_fee_amount` = 50000
- Query `get_total_effective_payables()`:
  * Baseline = 50000 (cancellation fee)
  * Commission/tax EXCLUDED (status-driven)
  * Adjustments (v=-1) still included

**Test Case 5: Supplier Change (Rebooking)**
- v1: ISSUED to Supplier A, amount_due = 300000
- v2: ISSUED to Supplier B, amount_due = 320000
- Verify both timeline versions stored immutably
- Query latest: Supplier B with amount 320000

**Test Case 6: Status-Driven Model Verification**
- Setup: ISSUED (v1) with commission 5000
- Action: Update to CancelledWithFee (v2)
- Query latest effective payables:
  * With status filter: cancellation_fee only
  * Raw aggregation: sum includes commission (wrong)
  * Verify correct method used
Refund Component Contract to Handle Lineage - [Component Data - Refund Closed]	As an Order PM, I want to retrieve refund component data with complete lineage, so that it's easy to understand the complete pricing lifecycle	**Event Contract: RefundIssuedEvent**
- `event_type`: "RefundIssued" (EventType.REFUND_ISSUED)
- `schema_version`: "refund.components.v1"
- `order_id`: Order identifier
- `refund_id`: Unique refund identifier
- `components`: Array of PricingComponent with:
  * `component_type`: Same as original (BaseFare, Tax, etc.)
  * `amount`: **NEGATIVE value** (refund amount)
  * `currency`: Currency code
  * `dimensions`: Same dimensions as original component
  * `is_refund`: true (automatically detected if not set)
  * `refund_of_component_semantic_id`: **REQUIRED** - Links to original component
    - Must reference existing semantic ID from prior snapshot
    - Enables lineage tracing
  * `description`: (optional) Refund reason
  * `meta`: (optional) Refund-specific metadata
- `emitted_at`: ISO8601 timestamp
- `emitter_service`: "refund-service"
- `meta`: (optional) Refund metadata

**Detail Context (for FX at refund):**
- Same structure as PricingUpdatedEvent
- `detail_context` or `detail_contexts` with:
  * `fx_context`: **FX rate effective at disbursement/closed**
    - `timestamp_fx_rate`: Disbursement timestamp
    - FX rates at refund time (may differ from original)
    - Enables FX gain/loss tracking
  * `entity_context`: Entity processing refund

**Normalization (Order Core):**
- Assigns `pricing_snapshot_id` and `version` (continues from order's version sequence)
- Validates `refund_of_component_semantic_id` exists
- Auto-detects `is_refund` = true if `refund_of_component_semantic_id` present
- Enriches metadata with refund context

**Storage:**
- Same `pricing_components_fact` table as regular components
- `is_refund` flag = 1
- `refund_of_component_semantic_id` populated
- Queryable via semantic ID for lineage	**Pydantic Models:**
- `RefundIssuedEvent` in `events.py`
- Reuses `PricingComponent` with refund-specific fields

**Normalization:**
- `pipeline.py::_ingest_refund_issued()` (if separate) or reuses pricing logic
- Same dual ID generation
- Lineage validation

**Storage:**
- Same `pricing_components_fact` table
- Filtered by `is_refund` column

**Query Patterns:**
- Query original component by semantic ID
- Query refund components by `refund_of_component_semantic_id`
- Aggregate net amount per semantic ID	**Test Case 1: Partial Refund**
- Original BaseFare = 500000 (semantic ID: cs-ORD-001-BaseFare)
- Refund 200000 of BaseFare
- Emit RefundIssuedEvent:
  * component with amount = -200000
  * `refund_of_component_semantic_id` = "cs-ORD-001-BaseFare"
- Verify `is_refund` = 1
- Verify new `pricing_snapshot_id` and incremented `version`

**Test Case 2: Full Refund Multiple Components**
- Original: BaseFare 500000, Tax 50000
- Refund both fully
- Emit 2 refund components in single event
- Both link to respective semantic IDs
- Verify both stored with same `pricing_snapshot_id`

**Test Case 3: Lineage Query**
- Query all components with semantic ID = "cs-ORD-001-BaseFare"
- Result:
  * v1: amount = 500000, is_refund = 0
  * v2: amount = -200000, is_refund = 1, refund_of = "cs-ORD-001-BaseFare"
- Net amount = 300000

**Test Case 4: FX at Refund**
- Original booked at FX rate 1.0
- Refund at FX rate 1.05 (IDR weakened)
- `detail_context.fx_context` at refund has different rates
- Verify FX context stored in refund component metadata
- Calculate FX gain/loss = (original - refund in same currency)

**Test Case 5: Invalid Lineage**
- Emit refund with `refund_of_component_semantic_id` = "nonexistent-id"
- Validation fails → event sent to DLQ
- Error type: VALIDATION_ERROR
- Error message includes "component not found"

**Test Case 6: Refund-Only Order**
- Edge case: refund event arrives before any pricing event (data issue)
- Handle gracefully: either DLQ or warn
- Order Explorer should not crash on refund-only orders
Refund Lifecycle Contract to Oversee Refund Lifecycle [Non-Component Data - Refund Status Updated]	As an Order PM, I want to ingest refund status into the pricing read layer, so that component lineage is connected with its lifecycle	**Event Contract: RefundLifecycleEvent**
- `event_type`: EventType.REFUND_INITIATED, REFUND_CLOSED, etc.
- `schema_version`: "refund.timeline.v1"
- `order_id`: Order identifier
- `refund_id`: Unique refund identifier
- `refund_timeline_version`: Monotonic version per refund_id
- `refund_amount`: Total refund amount
- `currency`: Currency code
- `refund_reason`: (optional) Reason for refund
- `emitted_at`: ISO8601 timestamp
- `emitter_service`: "refund-service"
- `metadata`: (optional) Additional refund information

**Purpose:**
- Separate from RefundIssuedEvent (which contains components)
- Tracks refund status progression: Initiated → Closed
- Enables queries like "show all refunds for order_id"
- Completes L3 (item-level) lineage understanding

**Storage:**
- `refund_timeline` table
- Indexed by order_id, refund_id
- Versioned by `refund_timeline_version`	**Pydantic Models:**
- `RefundLifecycleEvent` in `events.py`

**Normalization:**
- `pipeline.py::_ingest_refund_lifecycle()` (if implemented)
- Validates refund_id uniqueness per version

**Storage:**
- `refund_timeline` table
- Separate from components table

**Query Methods:**
- `get_refund_timeline_by_order()`
- `get_refund_timeline_by_refund_id()`	**Test Case 1: Refund Initiated**
- Emit REFUND_INITIATED event
- `refund_amount` = 200000
- `refund_reason` = "Customer request"
- Verify `refund_timeline_version` = 1

**Test Case 2: Refund Closed**
- Emit REFUND_CLOSED event for same refund_id
- Verify `refund_timeline_version` = 2
- Query timeline: verify 2 events for this refund

**Test Case 3: Multiple Refunds per Order**
- Order has 3 order_details
- Each detail has separate refund
- Emit 3 separate refund lifecycle events
- Verify 3 distinct refund_ids
- Query by order_id: returns all 3 refunds

**Test Case 4: Timeline + Components Integration**
- Refund timeline shows status progression
- Refund components show amount breakdown
- Join query: get refund status + component details
- Verify consistency (timeline amount = sum of components)
Snapshot Versioning Assignment from Order (Event-Level)	As an Order PM, I want any component data to enter the layer immutably with snapshots per component and per order, so that I can track pricing evolution	**Version Key Assignment Rules:**

**1. Pricing Snapshot Version (Components):**
- Producer event: `PricingUpdatedEvent` or `RefundIssuedEvent`
- Order Core assigns:
  * `pricing_snapshot_id`: UUID (unique per event)
  * `version`: Monotonic integer per order_id (v1, v2, v3, ...)
- Example evolution:
  * v1: Initial booking pricing
  * v2: Partial refund components appended
  * v3: Repricing due to fare change
  * v4: Another partial refund
- Each version is immutable (append-only)

**2. Payment Timeline Version:**
- Producer event: `PaymentLifecycleEvent`
- Order Core assigns:
  * `timeline_version`: Monotonic integer per order_id
- Evolution example:
  * v1: Authorized (checkout)
  * v2: Captured (full payment)
  * v3: Refunded (partial)

**3. Supplier Timeline Version:**
- Producer event: `SupplierLifecycleEvent`
- Order Core assigns:
  * `supplier_timeline_version`: Monotonic integer per order_detail_id
- Evolution example:
  * v1: ISSUED to Supplier A
  * v2: CancelledWithFee (rebooking to Supplier B)
  * v3: ISSUED to Supplier B

**4. Refund Timeline Version:**
- Producer event: `RefundLifecycleEvent`
- Order Core assigns:
  * `refund_timeline_version`: Monotonic integer per refund_id

**Idempotency:**
- Producer can optionally provide `event_id`
- Order Core validates: same `event_id` + `order_id` → skip processing
- Prevents duplicate version assignment

**Immutability:**
- No UPDATE operations on versioned tables
- All changes are INSERT with new version
- Previous snapshots remain queryable	**Implementation:**
- `pipeline.py::ingest_event()` routes by event_type
- Each ingestion method assigns appropriate version key
- Version retrieval methods in `database.py`:
  * `get_latest_pricing_version(order_id)`
  * `get_latest_payment_timeline_version(order_id)`
  * `get_latest_supplier_timeline_version(order_detail_id)`

**Storage Schema:**
- All versioned tables have version column
- Indexed for efficient latest-version queries
- No UNIQUE constraint on (order_id, version) to allow concurrent inserts (use optimistic locking if needed)	**Test Case 1: Pricing Version Sequence**
- Emit PricingUpdatedEvent → v1
- Emit RefundIssuedEvent → v2
- Emit PricingUpdatedEvent (repricing) → v3
- Verify monotonic sequence 1, 2, 3
- Verify all `pricing_snapshot_id` are distinct

**Test Case 2: Payment Version Independence**
- Emit PricingUpdatedEvent → pricing v1
- Emit PaymentLifecycleEvent → payment v1
- Emit PaymentLifecycleEvent → payment v2
- Emit PricingUpdatedEvent → pricing v2
- Verify payment versions (1, 2) independent of pricing versions (1, 2)

**Test Case 3: Supplier Version per Order Detail**
- Order has 2 order_details (OD-001, OD-002)
- Emit SupplierLifecycleEvent for OD-001 → version 1
- Emit SupplierLifecycleEvent for OD-002 → version 1 (independent counter)
- Emit SupplierLifecycleEvent for OD-001 → version 2
- Verify OD-001 has versions (1, 2), OD-002 has version (1)

**Test Case 4: Idempotency**
- Emit PricingUpdatedEvent with `event_id` = "evt-001"
- Re-emit same event with same `event_id`
- Verify only 1 version created (v1)
- Verify no duplicate components

**Test Case 5: Concurrent Ingestion**
- Simulate 2 events arriving simultaneously for same order
- Both retrieve `latest_version` = 1
- Both try to insert version 2
- Handle race condition:
  * Option A: Retry with incremented version
  * Option B: Use database-level sequence/auto-increment
- Verify final versions are (2, 3) not (2, 2)

**Test Case 6: Immutability Verification**
- Insert pricing v1
- Attempt UPDATE on version 1 → should fail (application-level constraint)
- Verify no UPDATE statements in codebase (code review)
- Verify append-only pattern enforced
Component Identity Assignment from Order (Component-Level)	As an Order System, I want to assign component-level identity both semantically and per snapshot, so that I can track component evolution and latest state	**Dual ID Strategy:**

**1. Component Semantic ID:**
- **Purpose:** Stable logical identity for same component across versions
- **Construction:** `{order_id}-{dimensions_canonical}-{component_type}-{optional_meta_key}`
- **Canonicalization Rules:**
  * Sort dimension keys alphabetically
  * Format: `key1-value1-key2-value2-...-ComponentType`
  * Example: `1325509981-1363607207-278791674-UPG-CGK-BaseFare`
    - order_id: 1325509981
    - order_detail_id: 1363607207
    - profile_id: 278791674
    - segment: UPG-CGK
    - component_type: BaseFare
- **Disambiguation (Meta Key):**
  * If multiple components have same (order_id, dimensions, component_type)
  * Example: Joint subsidy from Tiket (-50000) + Supplier (-25000)
  * Use `meta` field value in semantic ID:
    - `1325...-Subsidy-tiket`
    - `1325...-Subsidy-supplier`
  * Meta key examples: funding_source, promo_code, policy_type

**2. Component Instance ID:**
- **Purpose:** Unique identifier per component occurrence in a snapshot
- **Construction:** `ci_{UUID}` or hash-based
- **Uniqueness:** One instance ID per (semantic_id, pricing_snapshot_id)
- **Use Case:** Distinguish same semantic component in different snapshots

**Stability Properties:**
- Semantic ID is **deterministic**: Same logical component → Same semantic ID
- Semantic ID is **stable** across:
  * Repricing (v1 BaseFare and v2 BaseFare have same semantic ID if unchanged)
  * Refunds (refund component links via `refund_of_component_semantic_id`)
  * Order lifecycle
- Instance ID is **bound** to semantic ID but unique per snapshot

**Refund Lineage:**
- Refund component's `refund_of_component_semantic_id` MUST reference existing semantic ID from prior snapshot
- Validation enforced during ingestion	**Implementation:**
- `id_generator.py::generate_dual_ids()` method
- Canonicalization logic:
  * Sort dimensions by key
  * Construct deterministic string
  * Handle optional meta key
- Hash-based semantic ID (SHA256) or readable format

**Storage:**
- `pricing_components_fact` table has:
  * `component_semantic_id` (indexed, non-unique)
  * `component_instance_id` (primary key or unique index)
- Query patterns:
  * Latest by semantic: `SELECT * WHERE component_semantic_id = X ORDER BY version DESC LIMIT 1`
  * All history: `SELECT * WHERE component_semantic_id = X ORDER BY version`	**Test Case 1: Semantic ID Stability**
- v1: BaseFare component with dimensions {order_detail_id: "OD-001", pax_id: "P1"}
  * Semantic ID = "cs-ORD-001-OD-001-P1-BaseFare"
- v2: Repricing, same BaseFare dimensions
  * Semantic ID = "cs-ORD-001-OD-001-P1-BaseFare" (SAME)
- Verify same semantic ID across versions

**Test Case 2: Instance ID Uniqueness**
- v1: BaseFare semantic ID "cs-ORD-001-...", instance ID "ci_abc123"
- v2: Same BaseFare semantic ID, instance ID "ci_def456" (DIFFERENT)
- Verify 2 distinct instance IDs for same semantic ID

**Test Case 3: Canonicalization**
- Vertical A sends dimensions: {pax_id: "P1", order_detail_id: "OD-001"}
- Vertical B sends dimensions: {order_detail_id: "OD-001", pax_id: "P1"} (different order)
- After canonicalization: both produce same semantic ID
- Verify no duplicate semantic IDs created

**Test Case 4: Disambiguation with Meta**
- Component 1: Subsidy -50000, meta.funding_source = "tiket"
  * Semantic ID = "cs-ORD-001-...-Subsidy-tiket"
- Component 2: Subsidy -25000, meta.funding_source = "supplier"
  * Semantic ID = "cs-ORD-001-...-Subsidy-supplier"
- Verify distinct semantic IDs despite same dimensions

**Test Case 5: Order-Level Component (Empty Dimensions)**
- Component: MDR Fee at order level, dimensions = {}
- Semantic ID = "cs-ORD-001-Fee" (no granularity)
- Verify semantic ID generated correctly

**Test Case 6: Refund Lineage Validation**
- Original: Semantic ID "cs-ORD-001-BaseFare"
- Refund: `refund_of_component_semantic_id` = "cs-ORD-001-BaseFare"
- Verify lineage link stored
- Query: "Show all components linked to cs-ORD-001-BaseFare" → returns original + refund

**Test Case 7: Query Latest State**
- v1: BaseFare 500000
- v2: Refund -200000 (same semantic ID in refund_of)
- Query latest by semantic ID: returns v1 original component
- Query net amount: 500000 + (-200000) = 300000
Supplier Payable Lines and Status-Driven Obligation Model [Supplier Payables - Multi-Party Breakdown]	As an Order PM and Finance team, I want supplier payables broken down by obligation type with status-driven calculation, so that we know exact amounts owed to suppliers, affiliates, and tax authorities	**Supplier Payable Lines Structure:**

**Obligation Types:**
- `SUPPLIER`: Baseline amount owed to supplier
- `AFFILIATE_COMMISSION`: Commission owed to affiliate partner (B2B reseller)
- `TAX_WITHHOLDING`: Tax on affiliate commission (e.g., VAT)
- `SUPPLIER_COMMISSION`: Commission owed TO supplier (incentive/bonus)
- `AFFILIATE_PENALTY`: Standalone adjustment (version = -1) from Salesforce for check-in failure, etc.
- `SUPPLIER_PENALTY`: Standalone adjustment (version = -1) for supplier-side penalties

**Payable Line Fields:**
- `line_id`: Unique identifier per line
- `event_id`: Source event
- `order_id`, `order_detail_id`: Identifiers
- `supplier_timeline_version`: Links to timeline event (or -1 for standalone)
- `obligation_type`: Enum above
- `party_id`: Who we owe (supplier_id, reseller_id)
- `party_name`: Display name
- `amount`: Payable amount
- `currency`: Currency code
- `calculation_basis`: e.g., "markup", "supplier_cost"
- `calculation_rate`: e.g., 0.1 for 10%
- `calculation_description`: Human-readable description
- `ingested_at`: Timestamp

**Status-Driven Obligation Model:**

**Logic:**
1. **Get latest supplier status** per order_detail_id
2. **Calculate baseline** from status:
   - ISSUED/Confirmed/Invoiced/Settled: `baseline = amount_due`, include commission/tax
   - CancelledWithFee: `baseline = cancellation_fee_amount`, EXCLUDE commission/tax
   - CancelledNoFee/Voided: `baseline = 0`, EXCLUDE commission/tax
3. **Get adjustment lines** (version = -1): ALWAYS included regardless of status
4. **Total effective payable** = baseline + adjustments

**Why Commission/Tax Excluded on Cancellation:**
- When supplier booking is cancelled, supplier cost is reduced/eliminated
- Commission is calculated on supplier cost → no cost = no commission
- Tax is on commission → no commission = no tax
- BUT standalone adjustments (penalties) persist regardless

**Version = -1 Convention:**
- Standalone adjustments (penalties/credits from Salesforce) use version = -1
- Distinguishes timeline-linked payables (version >= 1) from standalone
- Query optimization: filter by version to include/exclude	**Implementation:**
- `database.py::get_total_effective_payables()` method implements status-driven logic
- `database.py::get_payables_by_party()` returns RAW aggregation (all lines summed - status-agnostic)
- `database.py::get_payables_timeline()` returns audit trail

**Storage:**
- `supplier_timeline` table (status progression)
- `supplier_payable_lines` table (breakdown)
- Join query for effective payables

**Ingestion:**
- `pipeline.py::_ingest_supplier_lifecycle()` creates payable lines
- Assigns `supplier_timeline_version` to all lines from same event
- Standalone adjustments assigned version = -1	**Test Case 1: Initial Issuance with Affiliate**
- ISSUED status (v1)
- Supplier amount = 300000
- Affiliate commission = 4694, tax = 516
- Query `get_total_effective_payables()`:
  * Baseline = 300000
  * Adjustments = [commission: 4694, tax: 516]
  * Total = 305210

**Test Case 2: Cancellation with Fee**
- Initial ISSUED (v1): supplier 300000, commission 5000, tax 550
- Update to CancelledWithFee (v2): cancellation_fee = 50000
- Query effective payables:
  * Latest status = CancelledWithFee
  * Baseline = 50000 (cancellation fee)
  * Commission/tax EXCLUDED (status-driven)
  * Total = 50000

**Test Case 3: Standalone Adjustment (Penalty)**
- ISSUED (v1): supplier 300000, commission 5000
- Salesforce emits penalty event (version = -1): penalty = 20000
- Query effective payables:
  * Baseline = 300000 (ISSUED)
  * Adjustments = [commission: 5000, penalty: 20000]
  * Total = 325000

**Test Case 4: Cancellation + Standalone Penalty**
- ISSUED (v1): supplier 300000, commission 5000
- CancelledWithFee (v2): cancellation_fee = 50000
- Penalty (v=-1): 20000
- Query effective payables:
  * Baseline = 50000 (cancellation fee)
  * Commission EXCLUDED (status-driven)
  * Penalty included (standalone, v=-1)
  * Total = 70000

**Test Case 5: Payables by Party**
- ISSUED with supplier, affiliate, tax
- Query `get_payables_by_party()`:
  * Party: supplier_id → total = 300000
  * Party: reseller_id → total = 4694 (AFFILIATE_COMMISSION)
  * Party: tax_authority → total = 516 (TAX_WITHHOLDING)

**Test Case 6: Supplier Change**
- v1: ISSUED to Supplier A (amount = 300000)
- v2: CancelledNoFee (Supplier A becomes obsolete)
- v3: ISSUED to Supplier B (amount = 320000)
- Query effective payables:
  * Latest status per order_detail: ISSUED (v3)
  * Baseline = 320000 (Supplier B)
  * Old Supplier A payables automatically excluded (not latest)

**Test Case 7: Payables Timeline Audit**
- Query `get_payables_timeline(order_id)`:
  * v1: SUPPLIER = 300000, AFFILIATE_COMMISSION = 5000
  * v2: (CancelledWithFee) no new lines, but affects calculation
  * v=-1: AFFILIATE_PENALTY = 20000
- Verify chronological order and versioning
DLQ (Dead Letter Queue) for Failed Events [Error Handling]	As an Order System, I want failed events captured in DLQ with error details, so that we can debug and replay failed ingestions	**DLQ Entry Structure:**
- `dlq_id`: Unique identifier (UUID)
- `event_id`: Original event_id (if present)
- `order_id`: Order identifier (if extractable)
- `event_type`: Original event type
- `error_type`: Category of error
  * VALIDATION_ERROR: Pydantic validation failed
  * SCHEMA_ERROR: Unknown event type or missing required fields
  * PIPELINE_ERROR: Unexpected exception during ingestion
- `error_message`: Detailed error description
- `raw_event`: Complete original event payload (JSON)
- `failed_at`: Timestamp of failure
- `retry_count`: Number of retry attempts
- `metadata`: Additional context

**Ingestion Flow:**
1. Receive event
2. Try to parse and validate (Pydantic)
3. If validation fails → send to DLQ with VALIDATION_ERROR
4. Try to ingest (assign IDs, insert to storage)
5. If ingestion fails → send to DLQ with PIPELINE_ERROR
6. Return IngestionResult with success/failure status

**Retry Mechanism:**
- Manual retry via UI or API
- Automated retry with exponential backoff (optional)
- Update `retry_count` on each attempt
- Move to permanent failure after N retries

**Monitoring:**
- Alert on DLQ entries exceeding threshold
- Dashboard showing error_type distribution
- Weekly DLQ review process	**Implementation:**
- `pipeline.py::_send_to_dlq()` method
- Try-catch blocks around all ingestion logic
- DLQ storage in `dlq` table

**UI:**
- Ingestion Console shows DLQ entries
- Raw Data Storage viewer has DLQ tab
- Retry button (future)

**Query Methods:**
- `get_dlq_entries(limit=100)`
- Filter by error_type, order_id, date range	**Test Case 1: Validation Error**
- Emit PricingUpdatedEvent with missing `order_id`
- Pydantic validation fails
- Verify DLQ entry:
  * error_type = VALIDATION_ERROR
  * error_message contains "order_id: field required"
  * raw_event stored

**Test Case 2: Schema Error**
- Emit event with unknown `event_type` = "UnknownEvent"
- Validation fails
- Verify DLQ entry with SCHEMA_ERROR

**Test Case 3: Pipeline Error**
- Mock database failure during insert
- Ingestion fails
- Verify DLQ entry with PIPELINE_ERROR

**Test Case 4: Retry Success**
- Event in DLQ due to temporary DB issue
- DB issue resolved
- Retry event from DLQ
- Verify successful ingestion
- Verify DLQ entry marked as resolved or deleted

**Test Case 5: Retry Failure**
- Event in DLQ with invalid data
- Retry multiple times
- Verify `retry_count` increments
- After N retries, mark as permanent failure

**Test Case 6: Monitoring**
- Generate 100 failed events (mix of error types)
- Query DLQ error type distribution
- Verify alert triggered if threshold exceeded
- Verify dashboard displays correctly
Raw Data Storage Visualization [Operational Visibility]	As an Operations/Engineering team, I want to view raw table contents after event ingestion, so that I can debug data flow and verify append-only architecture	**UI Features:**

**Order Filter:**
- Dropdown: "All Orders" or specific order_id
- Refresh button

**Table Tabs:**
1. **Pricing Components Fact**
   - Show all columns: semantic_id, instance_id, order_id, version, component_type, amount, currency, dimensions, is_refund, refund_of_component_semantic_id, etc.
   - JSON columns (dimensions, metadata) formatted with indentation
   - Highlight refund components (is_refund = 1)
   - CSV export

2. **Payment Timeline**
   - Show timeline_version, status, payment_id, pg_reference_id, amounts, instrument, bnpl_plan
   - JSON columns formatted
   - CSV export

3. **Supplier Timeline**
   - Show supplier_timeline_version, status, supplier_id, amount, cancellation_fee_amount
   - Warn on cancelled statuses
   - CSV export

4. **Supplier Payable Lines**
   - Show all payable lines with obligation_type, party_id, amount, supplier_timeline_version
   - Highlight version = -1 (standalone adjustments) with metrics:
     * Timeline-linked payables count
     * Standalone adjustments count
   - CSV export

5. **Refund Timeline**
   - Show refund_timeline_version, refund_id, refund_amount, refund_reason
   - CSV export

6. **DLQ (Failed Events)**
   - Show error_type, error_message, failed_at, raw_event
   - Error type breakdown bar chart
   - CSV export

**Display Features:**
- Horizontal scrolling for wide tables
- Row count indicator
- Pandas DataFrame rendering
- Column headers visible
- JSON pretty-printing	**Implementation:**
- `src/ui/raw_storage_viewer.py` module
- Integrated into `app.py` navigation
- Uses Streamlit dataframe component

**Query Methods:**
- Direct SQL queries to all tables
- Column name extraction via `cursor.description`
- DataFrame construction with proper headers

**Styling:**
- Consistent with dark theme
- Color coding for tracks (customer, payment, supplier, refund)
- Responsive design	**Test Case 1: View Pricing Components**
- Ingest order with 3 components
- Navigate to Raw Data Storage → Pricing Components tab
- Verify 3 rows displayed
- Verify columns: component_semantic_id, component_instance_id, amount, etc.
- Verify JSON columns formatted

**Test Case 2: Filter by Order**
- Ingest 2 orders (ORD-001, ORD-002)
- Select ORD-001 from dropdown
- Verify only ORD-001 data displayed across all tabs

**Test Case 3: Supplier Payables Highlighting**
- Ingest supplier event with commission (v1)
- Ingest penalty event (v=-1)
- Navigate to Supplier Payables tab
- Verify metrics:
  * Timeline-linked: 2 (supplier + commission)
  * Standalone: 1 (penalty)

**Test Case 4: DLQ Visualization**
- Ingest 5 failed events (3 validation, 2 schema errors)
- Navigate to DLQ tab
- Verify error type breakdown chart shows:
  * VALIDATION_ERROR: 3
  * SCHEMA_ERROR: 2

**Test Case 5: CSV Export**
- Navigate to any tab
- Click "Download as CSV"
- Verify CSV file downloaded
- Verify filename includes order_id

**Test Case 6: Refresh Functionality**
- View Raw Data Storage for order
- Ingest new event for same order in background
- Click Refresh button
- Verify new data appears immediately
Order Explorer - Computed Views [Consumer Interface]	As a CS agent or Finance analyst, I want computed order views showing latest pricing, payment status, and supplier info, so that I can quickly understand order state without manual aggregation	**Computed Views:**

**1. Latest Pricing Breakdown:**
- Query latest components by semantic ID (not all historical versions)
- Aggregate:
  * Total amount by component_type
  * Net amount per semantic ID (original - refunds)
  * Order total
- Display:
  * Component breakdown table
  * Total amount
  * Refund components separately highlighted

**2. Payment Timeline:**
- Show progression: Authorized → Captured
- Display:
  * Latest payment status
  * Payment method + instrument masked
  * Amounts: authorized, captured, captured_total
  * BNPL schedule (if applicable)

**3. Supplier Information:**
- Per order_detail_id:
  * Latest supplier status
  * Supplier name, booking_code
  * Effective payables (status-driven calculation)
  * Breakdown by party (supplier, affiliate, tax)

**4. Refund Summary:**
- Total refund amount
- Refund timeline status
- Refund components with lineage

**UI Layout:**
- Order selector dropdown
- Tabs: Pricing | Payment | Supplier | Refunds
- Summary metrics at top
- Detailed breakdown tables below	**Implementation:**
- `src/ui/order_explorer.py` module
- Query methods:
  * `get_latest_pricing_by_semantic()`
  * `get_payment_timeline_latest()`
  * `get_supplier_timeline_latest()`
  * `get_total_effective_payables()`

**Aggregation:**
- Latest-only queries (not full history)
- Net calculations for refunds
- Status-driven payables

**Display:**
- Streamlit expanders for sections
- Dataframes for tables
- Metrics for summary	**Test Case 1: Pricing Breakdown**
- Order with BaseFare 500000, Tax 50000
- Query latest pricing
- Verify breakdown:
  * BaseFare: 500000
  * Tax: 50000
  * Total: 550000

**Test Case 2: Pricing with Refund**
- Original: BaseFare 500000
- Refund: -200000
- Query latest pricing
- Verify:
  * BaseFare net: 300000 (500000 - 200000)
  * Refund section shows -200000 linked to BaseFare

**Test Case 3: Payment Status**
- Authorized: 500000
- Captured: 500000
- Query latest payment timeline
- Verify status = Captured, amount = 500000

**Test Case 4: Supplier Payables**
- ISSUED: supplier 300000, commission 5000
- Query effective payables
- Verify breakdown:
  * Supplier: 300000
  * Affiliate: 5000
  * Total: 305000

**Test Case 5: Cancelled Supplier**
- ISSUED (v1): 300000 + commission 5000
- CancelledWithFee (v2): fee 50000
- Query effective payables
- Verify:
  * Baseline: 50000 (cancellation fee)
  * Commission excluded
  * Total: 50000

**Test Case 6: Edge Case - Refund-Only Order**
- Order has only refund components (no original pricing)
- Query Order Explorer
- Verify:
  * Warning: "No regular pricing components"
  * Refund components still displayed
  * No crash
Multi-Order-Detail Support (Option A) [Complex Order Handling]	As a Vertical PM, I want to send pricing for orders with multiple order_details in a single event, so that I can efficiently emit complex order pricing	**Option A Implementation:**

**Event Structure:**
- Support BOTH:
  * `detail_context` (singular) - legacy, single order_detail
  * `detail_contexts` (array) - new, multiple order_details

**Matching Logic:**
1. Build context map: `order_detail_id` → `DetailContext`
2. For each component:
   - Extract `order_detail_id` from `component.dimensions`
   - Find matching context in map
   - Enrich component metadata with matched context (entity, FX)
3. If no match found, component metadata remains minimal

**Benefits:**
- Single event for multi-detail orders (e.g., hotel multi-room, flight multi-pax)
- Each order_detail can have different:
  * Entity code (TNPL vs GTN)
  * FX context (different supply currencies per supplier)
- Backward compatible with single detail_context

**Example:**
- Flight order with 2 passengers (2 order_details)
- detail_contexts = [
    {order_detail_id: "OD-001", entity_context: {entity_code: "TNPL"}},
    {order_detail_id: "OD-002", entity_context: {entity_code: "GTN"}}
  ]
- Components have dimensions with order_detail_id matching contexts
- Order Core matches and enriches each component	**Implementation:**
- `pipeline.py::_ingest_pricing_updated()` lines 98-107
- Context map building
- Component matching by order_detail_id
- Metadata enrichment

**Validation:**
- Warn if component's order_detail_id not in context map
- Allow unmatched (some components may not need context)

**Storage:**
- Component metadata includes matched context
- Query can filter/join by entity_context	**Test Case 1: Single Order Detail (Legacy)**
- Emit event with `detail_context` (singular)
- 3 components, all with same order_detail_id
- Verify all components enriched with same context

**Test Case 2: Multi Order Detail (Option A)**
- Emit event with `detail_contexts` array (2 contexts)
- 4 components: 2 for OD-001, 2 for OD-002
- Verify each component matched to correct context
- Verify metadata includes entity_context per match

**Test Case 3: Partial Match**
- detail_contexts has OD-001 only
- Components have OD-001 and OD-002
- Verify OD-001 components enriched
- Verify OD-002 components have minimal metadata (no match)

**Test Case 4: Different Entity per Detail**
- OD-001: entity_code = "TNPL"
- OD-002: entity_code = "GTN"
- Components matched accordingly
- Query by entity_code: returns correct subset

**Test Case 5: Different FX per Detail**
- OD-001: supply_currency = "USD", fx_rate = 15000
- OD-002: supply_currency = "SGD", fx_rate = 11000
- Components enriched with different FX contexts
- Verify FX calculation per component uses correct rate

**Test Case 6: Backward Compatibility**
- Old producer sends `detail_context` (singular)
- New ingestion logic supports both
- Verify no breaking changes
- Verify context applied correctly
